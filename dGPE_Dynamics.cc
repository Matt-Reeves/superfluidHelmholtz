
// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_ALL_LOG_LEVELS)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if ((_rank == 0) || (logLevel & ~(_SIMULATION_LOG_LEVEL | _SEGMENT_LOG_LEVEL | _SAMPLE_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL))) { \
        if (logLevel & ~(_SIMULATION_LOG_LEVEL | _SEGMENT_LOG_LEVEL | _SAMPLE_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
          printf("Rank[%i]: ", _rank); \
        if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
            printf("%s:%i: ", __FILE__, __LINE__); \
        printf(__VA_ARGS__); \
        fflush(stdout); \
      } \
      if (logLevel & _ERROR_LOG_LEVEL) \
        MPI_Abort(MPI_COMM_WORLD, 1); \
      else if (logLevel & _NO_ERROR_TERMINATE_LOG_LEVEL) \
        MPI_Finalize(); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#include <getopt.h>

#if (CFG_COMPILER == CFG_COMPILER_MSVC)
  #define FFTW_DLL
#endif

#include <fftw3.h>
#include <sys/stat.h>
#include <sys/types.h>

#define _xmds_malloc fftw_malloc
#define xmds_free fftw_free
#include <fftw3-mpi.h>

#include <mpi.h>

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE

#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Auto-vectorisation defines

#define _MAKE_AUTOVEC_VARIABLE(x) real* const __restrict__ x ## _autovec = (real*) x
#define _AUTOVEC(x) (x ## _autovec)

// ********************************************************
//   Distributed MPI Simulation Driver defines
#undef MPI_REAL
#define MPI_REAL MPI_DOUBLE

// ********************************************************
//   Geometry defines
#define _lattice_x ((int)numGridPoints1)
#define _min_x     ((real)xmin)
#define _max_x     ((real)xmax)
#define _dx        ((real)((_max_x - _min_x)/_lattice_x))

#define _lattice_kx ((int)numGridPoints1)
#define _dkx        (2.0*M_PI/(_max_x - _min_x))
#define _min_kx     (-(_lattice_kx/2) * _dkx)
#define _max_kx     ((_lattice_kx - 1)/2 * _dkx)

#define _lattice_y ((int)numGridPoints2)
#define _min_y     ((real)ymin)
#define _max_y     ((real)ymax)
#define _dy        ((real)((_max_y - _min_y)/_lattice_y))

#define _lattice_ky ((int)numGridPoints2)
#define _dky        (2.0*M_PI/(_max_y - _min_y))
#define _min_ky     (-(_lattice_ky/2) * _dky)
#define _max_ky     ((_lattice_ky - 1)/2 * _dky)

// ********************************************************
//   field xy defines
#define _xy_ndims 2


// vector init_wavefunction defines
#define _xy_init_wavefunction_ncomponents 2

// vector initial_noise defines
#define _xy_initial_noise_ncomponents 2

// vector gainloss defines
#define _xy_gainloss_ncomponents 2

// vector potential defines
#define _xy_potential_ncomponents 1

// vector kinetic defines
#define _xy_kinetic_ncomponents 1

// vector wavefunction defines
#define _xy_wavefunction_ncomponents 1

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) defines
// vector segment2_xy_operators_operator0_field defines
#define _xy_segment2_xy_operators_operator0_field_ncomponents 1

// vector segment2_xy_operators_operator0_result defines
#define _xy_segment2_xy_operators_operator0_result_ncomponents 1

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 2


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 3


#define _mg0_output_lattice_t ((int)1000)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 2

// ********************************************************
//   field dimensionless defines
#define _dimensionless_ndims 0



// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;

_basis_map _xy_segment2_xy_operators_operator0_result_basis_map;
_basis_map _xy_kinetic_basis_map;
_basis_map _xy_wavefunction_basis_map;

real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
  /* 0 */ "(distributed ky, kx)",
  /* 1 */ "(distributed x, y)",
};

// ********************************************************
//   'Globals' element globals

#line 27 "./Dynamics.xml"

const double  Uint = 1;
const double mu0 = 1.0;
const double R1 = 100;
const double R2 = 40;

#line 331 "dGPE_Dynamics.cc"

// ********************************************************
//   Command line argument processing globals
real xmin = -128.0; 
real xmax = 128.0; 
real ymin = -128.0; 
real ymax = 128.0; 
integer numGridPoints1 = 256; 
integer numGridPoints2 = 256; 
real gamma0 = 0.02; 

// ********************************************************
//   FFTW3 with MPI globals
const real _inverse_sqrt_2pi = 1.0 / sqrt(2.0 * M_PI); 
string _fftwWisdomPath;
ptrdiff_t _block_size_x = FFTW_MPI_DEFAULT_BLOCK;
ptrdiff_t _block_size_kx = FFTW_MPI_DEFAULT_BLOCK;
ptrdiff_t _block_size_y = FFTW_MPI_DEFAULT_BLOCK;
ptrdiff_t _block_size_ky = FFTW_MPI_DEFAULT_BLOCK;

// ********************************************************
//   Distributed MPI Simulation Driver globals
int _rank, _size;

// ********************************************************
//   Geometry globals
real* _x = NULL;
ptrdiff_t _local_unswapped_lattice_x = 0;
ptrdiff_t _local_unswapped_offset_x = 0;

real* _kx = NULL;
ptrdiff_t _local_unswapped_lattice_kx = 0;
ptrdiff_t _local_unswapped_offset_kx = 0;

real* _y = NULL;
ptrdiff_t _local_swapped_lattice_y = 0;
ptrdiff_t _local_swapped_offset_y = 0;

real* _ky = NULL;
ptrdiff_t _local_swapped_lattice_ky = 0;
ptrdiff_t _local_swapped_offset_ky = 0;

// ********************************************************
//   field xy globals
// vector init_wavefunction globals
size_t _xy_init_wavefunction_alloc_size = 0;
real* _xy_init_wavefunction = NULL;
real* _active_xy_init_wavefunction = NULL;

// vector initial_noise globals
size_t _xy_initial_noise_alloc_size = 0;
real* _xy_initial_noise = NULL;
real* _active_xy_initial_noise = NULL;

uint32_t _gen_initial_noise_seeds[10];
unsigned short _gen_initial_noise[3];

// vector gainloss globals
size_t _xy_gainloss_alloc_size = 0;
real* _xy_gainloss = NULL;
real* _active_xy_gainloss = NULL;

// vector potential globals
size_t _xy_potential_alloc_size = 0;
real* _xy_potential = NULL;
real* _active_xy_potential = NULL;

// vector kinetic globals
size_t _xy_kinetic_alloc_size = 0;
complex* _xy_kinetic = NULL;
complex* _active_xy_kinetic = NULL;

ptrdiff_t _xy_kinetic_basis = -1;

// vector wavefunction globals
size_t _xy_wavefunction_alloc_size = 0;
complex* _xy_wavefunction = NULL;
complex* _active_xy_wavefunction = NULL;

ptrdiff_t _xy_wavefunction_basis = -1;

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) globals
complex* _segment2_akfield_xy_wavefunction;
complex* _segment2_aifield_xy_wavefunction;
complex* _segment2_ajfield_xy_wavefunction;
complex* _segment2_alfield_xy_wavefunction;
complex* _segment2_checkfield_xy_wavefunction;

// vector segment2_xy_operators_operator0_field globals
size_t _xy_segment2_xy_operators_operator0_field_alloc_size = 0;
complex* _xy_segment2_xy_operators_operator0_field = NULL;
complex* _active_xy_segment2_xy_operators_operator0_field = NULL;

// vector segment2_xy_operators_operator0_result globals
size_t _xy_segment2_xy_operators_operator0_result_alloc_size = 0;
complex* _xy_segment2_xy_operators_operator0_result = NULL;
complex* _active_xy_segment2_xy_operators_operator0_result = NULL;

ptrdiff_t _xy_segment2_xy_operators_operator0_result_basis = -1;

// ********************************************************
//   segment 3 (Breakpoint) globals
long _breakpointAutoNameCounter = 0;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Transform Multiplexer function prototypes
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);

// ********************************************************
//   Command line argument processing function prototypes
void _print_usage();

// ********************************************************
//   field xy function prototypes
void _xy_init_wavefunction_initialise();

void _xy_initial_noise_evaluate();

void _xy_gainloss_initialise();

void _xy_potential_initialise();

void _xy_kinetic_initialise();
void _xy_kinetic_basis_transform(ptrdiff_t new_basis);
void _xy_kinetic_evaluate();

void _xy_wavefunction_initialise();
void _xy_wavefunction_basis_transform(ptrdiff_t new_basis);

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (Filter) function prototypes
void _segment1();

void _segment1__evaluate_operator0();

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) function prototypes
void _segment2();
inline void _segment2_calculate_delta_a(real _step);
inline void _segment2_ip_evolve(int _exponent);
inline void _segment2_calculate_nonconstant_ip_fields(real _step, int _exponent);
real _segment2_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter);
real _segment2_xy_wavefunction_timestep_error(complex* _checkfield);
bool _segment2_xy_wavefunction_reset(complex* _reset_to);

void _segment2_xy_operators_evaluate_operator0();
void _segment2_xy_operators_calculate_operator0_field();

void _xy_segment2_xy_operators_operator0_result_basis_transform(ptrdiff_t new_basis);

void _segment2_xy_operators_evaluate_operator1(real _step);

// ********************************************************
//   segment 3 (Breakpoint) function prototypes
void _segment3();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   output function prototypes
void _write_output();

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  MPI_Init(&argc, &argv);
  MPI_Comm_size(MPI_COMM_WORLD, &_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &_rank);

  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'dGPE_Dynamics' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
  // *********** Parse the command line for arguments, and set  *********
  // *********** the appropriate global variables               *********
  
  int resp;
  std::map<string, string> mInputArgsAndValues;
  
  while (1) {
    static struct option long_options[] = 
      {
        {"help", no_argument, 0, 'h'},
        {"xmin", required_argument, 0, 'x'},
        {"xmax", required_argument, 0, 'm'},
        {"ymin", required_argument, 0, 'y'},
        {"ymax", required_argument, 0, 'a'},
        {"numGridPoints1", required_argument, 0, 'n'},
        {"numGridPoints2", required_argument, 0, 'u'},
        {"gamma0", required_argument, 0, 'g'},
        {NULL, 0, 0, 0}
      };
    
    int option_index = 0;
  
    resp = getopt_long(argc, argv, "hx:m:y:a:n:u:g:", long_options, &option_index);
    
    if (resp == -1)
      break;
  
    switch (resp) {
      case '?':
        // An unknown option was passed. Show allowed options and exit. 
        _print_usage(); // This causes the simulation to exit
  
      case 'h':
        _print_usage(); // This causes the simulation to exit
      
      case 'x':
        xmin = strtod(optarg, NULL);
        break;
      
      case 'm':
        xmax = strtod(optarg, NULL);
        break;
      
      case 'y':
        ymin = strtod(optarg, NULL);
        break;
      
      case 'a':
        ymax = strtod(optarg, NULL);
        break;
      
      case 'n':
        numGridPoints1 = strtol(optarg, NULL, 10);
        break;
      
      case 'u':
        numGridPoints2 = strtol(optarg, NULL, 10);
        break;
      
      case 'g':
        gamma0 = strtod(optarg, NULL);
        break;
        
      default:
        _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
    }
  }
  
  
  if (optind < argc)
    _print_usage(); // This causes the simulation to exit.
  
  // ******** Argument post-processing code *******
  // **********************************************
  
    // First work out the local lattice and offset for the geometry
    ptrdiff_t _sizes[3];
    fftw_mpi_init();
    _sizes[0] = _lattice_x; _sizes[1] = _lattice_y;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_x, _block_size_y, MPI_COMM_WORLD,
      &_local_unswapped_lattice_x, &_local_unswapped_offset_x,
      &_local_swapped_lattice_y, &_local_swapped_offset_y
    );
    
    if (_rank == 0) {
      _block_size_x = _local_unswapped_lattice_x;
      _block_size_y = _local_swapped_lattice_y;
    }
    MPI_Bcast(&_block_size_x, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_y, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    _sizes[0] = _lattice_x; _sizes[1] = _lattice_ky;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_x, _block_size_ky, MPI_COMM_WORLD,
      &_local_unswapped_lattice_x, &_local_unswapped_offset_x,
      &_local_swapped_lattice_ky, &_local_swapped_offset_ky
    );
    
    if (_rank == 0) {
      _block_size_x = _local_unswapped_lattice_x;
      _block_size_ky = _local_swapped_lattice_ky;
    }
    MPI_Bcast(&_block_size_x, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_ky, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    _sizes[0] = _lattice_kx; _sizes[1] = _lattice_y;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_kx, _block_size_y, MPI_COMM_WORLD,
      &_local_unswapped_lattice_kx, &_local_unswapped_offset_kx,
      &_local_swapped_lattice_y, &_local_swapped_offset_y
    );
    
    if (_rank == 0) {
      _block_size_kx = _local_unswapped_lattice_kx;
      _block_size_y = _local_swapped_lattice_y;
    }
    MPI_Bcast(&_block_size_kx, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_y, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    _sizes[0] = _lattice_kx; _sizes[1] = _lattice_ky;
    fftw_mpi_local_size_many_transposed(
      2, _sizes, 1, _block_size_kx, _block_size_ky, MPI_COMM_WORLD,
      &_local_unswapped_lattice_kx, &_local_unswapped_offset_kx,
      &_local_swapped_lattice_ky, &_local_swapped_offset_ky
    );
    
    if (_rank == 0) {
      _block_size_kx = _local_unswapped_lattice_kx;
      _block_size_ky = _local_swapped_lattice_ky;
    }
    MPI_Bcast(&_block_size_kx, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&_block_size_ky, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
    
    
  
  _xy_initial_noise_alloc_size = MAX(_xy_initial_noise_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_initial_noise_ncomponents);
  _xy_init_wavefunction_alloc_size = MAX(_xy_init_wavefunction_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_init_wavefunction_ncomponents);
  _xy_segment2_xy_operators_operator0_field_alloc_size = MAX(_xy_segment2_xy_operators_operator0_field_alloc_size, (_local_swapped_lattice_ky * _lattice_kx) * _xy_segment2_xy_operators_operator0_field_ncomponents);
  _xy_gainloss_alloc_size = MAX(_xy_gainloss_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_gainloss_ncomponents);
  _xy_potential_alloc_size = MAX(_xy_potential_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_potential_ncomponents);
  _xy_kinetic_alloc_size = MAX(_xy_kinetic_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_kinetic_ncomponents);
  _xy_kinetic_alloc_size = MAX(_xy_kinetic_alloc_size, (_local_swapped_lattice_ky * _lattice_kx) * _xy_kinetic_ncomponents);
  _xy_wavefunction_alloc_size = MAX(_xy_wavefunction_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents);
  _xy_wavefunction_alloc_size = MAX(_xy_wavefunction_alloc_size, (_local_swapped_lattice_ky * _lattice_kx) * _xy_wavefunction_ncomponents);
  _xy_segment2_xy_operators_operator0_result_alloc_size = MAX(_xy_segment2_xy_operators_operator0_result_alloc_size, (_local_unswapped_lattice_x * _lattice_y) * _xy_segment2_xy_operators_operator0_result_ncomponents);
  _xy_segment2_xy_operators_operator0_result_alloc_size = MAX(_xy_segment2_xy_operators_operator0_result_alloc_size, (_local_swapped_lattice_ky * _lattice_kx) * _xy_segment2_xy_operators_operator0_result_ncomponents);
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t * _local_unswapped_lattice_x * _lattice_y) * _mg0_output_raw_ncomponents);
  ptrdiff_t _local_alloc_size, _tmp;
  _sizes[0] = _lattice_x;
  _sizes[1] = _lattice_y;
  _local_alloc_size = fftw_mpi_local_size_many_transposed(
    2, _sizes,
    (ptrdiff_t)_xy_segment2_xy_operators_operator0_result_ncomponents,
    _block_size_x, _block_size_ky,
    MPI_COMM_WORLD,
    &_tmp, &_tmp, &_tmp, &_tmp /* Local lattices and offsets were obtained above */
  );
  _xy_segment2_xy_operators_operator0_result_alloc_size = MAX(_xy_segment2_xy_operators_operator0_result_alloc_size, (_local_alloc_size));
  _xy_kinetic_alloc_size = MAX(_xy_kinetic_alloc_size, (_local_alloc_size));
  _xy_wavefunction_alloc_size = MAX(_xy_wavefunction_alloc_size, (_local_alloc_size));
  
  _x = (real*) xmds_malloc(sizeof(real) * (_lattice_x+1));
  
  _kx = (real*) xmds_malloc(sizeof(real) * (_lattice_kx+1));
  
  _y = (real*) xmds_malloc(sizeof(real) * (_lattice_y+1));
  
  _ky = (real*) xmds_malloc(sizeof(real) * (_lattice_ky+1));
  
  _xy_init_wavefunction = (real*) xmds_malloc(sizeof(real) * MAX(_xy_init_wavefunction_alloc_size,1));
  _active_xy_init_wavefunction = _xy_init_wavefunction;
  
  
  _xy_initial_noise = (real*) xmds_malloc(sizeof(real) * MAX(_xy_initial_noise_alloc_size,1));
  _active_xy_initial_noise = _xy_initial_noise;
  
  
  _xy_gainloss = (real*) xmds_malloc(sizeof(real) * MAX(_xy_gainloss_alloc_size,1));
  _active_xy_gainloss = _xy_gainloss;
  
  
  _xy_potential = (real*) xmds_malloc(sizeof(real) * MAX(_xy_potential_alloc_size,1));
  _active_xy_potential = _xy_potential;
  
  
  _xy_kinetic = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_kinetic_alloc_size,1));
  _active_xy_kinetic = _xy_kinetic;
  
  
  _xy_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_wavefunction_alloc_size,1));
  _active_xy_wavefunction = _xy_wavefunction;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  
  
  // Run-time validation checks
  
  if (xmin >= xmax)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'xmax' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)xmin, (real)xmax);
  
  if (ymin >= ymax)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'ymax' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)ymin, (real)ymax);
  
  if (numGridPoints1 > numGridPoints1)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Can't sample more points in dimension 'x' than\n"
                           "there are points in the full dimension.\n"
                           "%i > %i.\n", (int)numGridPoints1, (int)numGridPoints1);
  
  if ( (numGridPoints1 > 0) && (numGridPoints1 % numGridPoints1 !=0) )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The number of sampling lattice points (%i) must divide the number\n"
                         "of lattice points on the simulation grid (%i).\n", (int)numGridPoints1, (int)numGridPoints1);
  
  
  if (numGridPoints2 > numGridPoints2)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Can't sample more points in dimension 'y' than\n"
                           "there are points in the full dimension.\n"
                           "%i > %i.\n", (int)numGridPoints2, (int)numGridPoints2);
  
  if ( (numGridPoints2 > 0) && (numGridPoints2 % numGridPoints2 !=0) )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The number of sampling lattice points (%i) must divide the number\n"
                         "of lattice points on the simulation grid (%i).\n", (int)numGridPoints2, (int)numGridPoints2);
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++)
    _x[_index_x] = _min_x + _index_x*_dx;
  for (long _index_kx = 0; _index_kx < (_lattice_kx+1)/2; _index_kx++)
    _kx[_index_kx] = _index_kx*_dkx;
  for (long _index_kx = (_lattice_kx+1)/2; _index_kx < _lattice_kx; _index_kx++)
    _kx[_index_kx] = -(_lattice_kx - _index_kx) * _dkx;
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++)
    _x[_index_x] = _min_x + _index_x*_dx;
  for (long _index_kx = 0; _index_kx < (_lattice_kx+1)/2; _index_kx++)
    _kx[_index_kx] = _index_kx*_dkx;
  for (long _index_kx = (_lattice_kx+1)/2; _index_kx < _lattice_kx; _index_kx++)
    _kx[_index_kx] = -(_lattice_kx - _index_kx) * _dkx;
  for (long _index_y = 0; _index_y < _lattice_y; _index_y++)
    _y[_index_y] = _min_y + _index_y*_dy;
  for (long _index_ky = 0; _index_ky < (_lattice_ky+1)/2; _index_ky++)
    _ky[_index_ky] = _index_ky*_dky;
  for (long _index_ky = (_lattice_ky+1)/2; _index_ky < _lattice_ky; _index_ky++)
    _ky[_index_ky] = -(_lattice_ky - _index_ky) * _dky;
  for (long _index_y = 0; _index_y < _lattice_y; _index_y++)
    _y[_index_y] = _min_y + _index_y*_dy;
  for (long _index_ky = 0; _index_ky < (_lattice_ky+1)/2; _index_ky++)
    _ky[_index_ky] = _index_ky*_dky;
  for (long _index_ky = (_lattice_ky+1)/2; _index_ky < _lattice_ky; _index_ky++)
    _ky[_index_ky] = -(_lattice_ky - _index_ky) * _dky;
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  
  #if HAVE_DEV_URANDOM
    uint32_t __seeds[10];
    FILE *__urandom_fp = fopen("/dev/urandom", "r");
  
    if (__urandom_fp == NULL) {
        _LOG(_ERROR_LOG_LEVEL, "Unable to seed random number generator from /dev/urandom.  Is it accessible?\n");
        // Implicit quit
    }
  
    size_t __entries_read = 0;
    __entries_read = fread(__seeds, sizeof(uint32_t), 10, __urandom_fp);
  
    if (__entries_read != 10) {
      _LOG(_ERROR_LOG_LEVEL, "Unable to read from /dev/urandom while seeding the random number generator.\n");
        // Implicit quit
    }
  
    fclose(__urandom_fp);
  
    for (unsigned long _i0=0; _i0 < 10; _i0++) {
      _gen_initial_noise_seeds[_i0] = (uint32_t) __seeds[_i0];
    }
  
  #else
  #error Do not have a run-time random number source! Please supply seeds manually.
  #endif
  // Only generate random seeds on the first rank, then distribute to all.
  unsigned long _local__gen_initial_noise_seeds[10];
  if (_rank == 0) {
    for (int _i0 = 0; _i0 < 10; _i0++)
        _local__gen_initial_noise_seeds[_i0] = (unsigned long)_gen_initial_noise_seeds[_i0];
  }
  // Broadcast seeds to other nodes
  MPI_Bcast(_local__gen_initial_noise_seeds, 10, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);
  // Copy to the correct array
  for (int _i0 = 0; _i0 < 10; _i0++)
      _gen_initial_noise_seeds[_i0] = (uint32_t)_local__gen_initial_noise_seeds[_i0];
  
  
  // load wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
  {
    char _hostName[256];
    gethostname(_hostName, 256);
    _hostName[255] = '\0'; // just in case
    
    string _pathToWisdom = getenv("HOME");
    _pathToWisdom += "/.xmds/wisdom/";
    
    string _wisdomFileName = _hostName;
    _wisdomFileName += ".wisdom";
    _wisdomFileName += ".fftw3_mpi";
    
    FILE *_fp = NULL;
    
    _fp = fopen(_pathToWisdom.c_str(), "r");
    if (_fp) {
      fclose(_fp);
    } else {
      int _result = mkdir((string(getenv("HOME")) + "/.xmds").c_str(), S_IRWXU);
      if (mkdir(_pathToWisdom.c_str(), S_IRWXU)) {
        // We failed to create the ~/.xmds/wisdom directory
        _LOG(_WARNING_LOG_LEVEL, "Warning: Cannot find enlightenment, the path to wisdom ~/.xmds/wisdom doesn't seem to exist and we couldn't create it.\n"
                                 "         I'll use the current path instead.\n");
        _pathToWisdom = ""; // present directory
      }
      
    }
    
    _fftwWisdomPath = _pathToWisdom + _wisdomFileName;
    
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "r")) != NULL) {
      _LOG(_SIMULATION_LOG_LEVEL, "Found enlightenment... (Importing wisdom)\n");
      fftw_import_wisdom_from_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  fftw_mpi_broadcast_wisdom(MPI_COMM_WORLD);
  #endif // POSIX
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (2 * _xy_segment2_xy_operators_operator0_result_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _xy_segment2_xy_operators_operator0_result_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_xy_segment2_xy_operators_operator0_result);
  }
  _basis_transform = &_xy_segment2_xy_operators_operator0_result_basis_map[_basis_pair(1, 0)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dx * _inverse_sqrt_2pi * _dy;
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _xy_segment2_xy_operators_operator0_result_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_swapped_lattice_ky * _lattice_kx,
    /* postfix lattice*/ _xy_segment2_xy_operators_operator0_result_ncomponents * 2
  );
  
  _basis_transform = &_xy_segment2_xy_operators_operator0_result_basis_map[_basis_pair(0, 1)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dkx * _inverse_sqrt_2pi * _dky;
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_swapped_lattice_ky * _lattice_kx,
    /* postfix lattice */ _xy_segment2_xy_operators_operator0_result_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _xy_segment2_xy_operators_operator0_result_ncomponents
  );
  
  if (2 * _xy_kinetic_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _xy_kinetic_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_xy_kinetic);
  }
  _basis_transform = &_xy_kinetic_basis_map[_basis_pair(1, 0)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dx * _inverse_sqrt_2pi * _dy;
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _xy_kinetic_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_swapped_lattice_ky * _lattice_kx,
    /* postfix lattice*/ _xy_kinetic_ncomponents * 2
  );
  
  _basis_transform = &_xy_kinetic_basis_map[_basis_pair(0, 1)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dkx * _inverse_sqrt_2pi * _dky;
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_swapped_lattice_ky * _lattice_kx,
    /* postfix lattice */ _xy_kinetic_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _xy_kinetic_ncomponents
  );
  
  if (2 * _xy_wavefunction_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _xy_wavefunction_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_xy_wavefunction);
  }
  _basis_transform = &_xy_wavefunction_basis_map[_basis_pair(1, 0)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dx * _inverse_sqrt_2pi * _dy;
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _xy_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_swapped_lattice_ky * _lattice_kx,
    /* postfix lattice*/ _xy_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_xy_wavefunction_basis_map[_basis_pair(0, 1)];
  _basis_transform->_multiplier = _inverse_sqrt_2pi * _dkx * _inverse_sqrt_2pi * _dky;
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ _local_swapped_lattice_ky * _lattice_kx,
    /* postfix lattice */ _xy_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _xy_wavefunction_ncomponents
  );
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  _transform_0(true, 1.0, _max_vector_array, _auxiliary_array, 1, _xy_segment2_xy_operators_operator0_result_ncomponents);
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  // Get the time at which the simulation started
  timeval _tim;
  gettimeofday(&_tim, NULL);
  double _startTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  
  // Work out how long the simulation has run for
  gettimeofday(&_tim, NULL);
  double _endTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  _LOG(_SIMULATION_LOG_LEVEL, "Time elapsed for simulation is: %.2f seconds\n", _endTime - _startTime);
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  fftw_mpi_gather_wisdom(MPI_COMM_WORLD);
  {
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
      fftw_export_wisdom_to_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  #endif // POSIX
  
  fftw_cleanup();
  
  // Bing!
  _LOG(_SIMULATION_LOG_LEVEL, "\a");
  
  xmds_free(_xy_init_wavefunction);
  _active_xy_init_wavefunction = _xy_init_wavefunction = NULL;
  
  
  xmds_free(_xy_initial_noise);
  _active_xy_initial_noise = _xy_initial_noise = NULL;
  
  
  xmds_free(_xy_gainloss);
  _active_xy_gainloss = _xy_gainloss = NULL;
  
  
  xmds_free(_xy_potential);
  _active_xy_potential = _xy_potential = NULL;
  
  
  xmds_free(_xy_kinetic);
  _active_xy_kinetic = _xy_kinetic = NULL;
  
  
  xmds_free(_xy_wavefunction);
  _active_xy_wavefunction = _xy_wavefunction = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  
  MPI_Finalize();
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Transform Multiplexer function implementations
// (distributed x, y) <---> (distributed ky, kx) transform
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  // _prefix_lattice should be 1
  // _postfix_lattice should be 1
  static fftw_plan _fftw_forward_plan = NULL;
  static fftw_plan _fftw_backward_plan = NULL;
  
  if (!_fftw_forward_plan) {
    _LOG(_SIMULATION_LOG_LEVEL, "Planning for (distributed x, y) <---> (distributed ky, kx) transform...");
    ptrdiff_t _transform_sizes[2];
    
    int _transform_sizes_index = 0;
    
    _transform_sizes[_transform_sizes_index++] = _lattice_x;
    _transform_sizes[_transform_sizes_index++] = _lattice_y;
    
    _fftw_forward_plan = fftw_mpi_plan_many_dft(
      _transform_sizes_index, _transform_sizes, _postfix_lattice,
      _block_size_x, _block_size_ky,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_in),
      MPI_COMM_WORLD, FFTW_FORWARD, FFTW_PATIENT | FFTW_MPI_TRANSPOSED_OUT
    );
    if (!_fftw_forward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward mpi dft plan.\n", __FILE__, __LINE__);
    
    _fftw_backward_plan = fftw_mpi_plan_many_dft(
      _transform_sizes_index, _transform_sizes, _postfix_lattice,
      _block_size_ky, _block_size_x,
      reinterpret_cast<fftw_complex*>(_data_in),
      reinterpret_cast<fftw_complex*>(_data_in),
      MPI_COMM_WORLD, FFTW_BACKWARD, FFTW_PATIENT | FFTW_MPI_TRANSPOSED_IN
    );
    if (!_fftw_backward_plan)
      _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward mpi dft plan.\n", __FILE__, __LINE__);
    
    
    // Save wisdom
    #if CFG_OSAPI == CFG_OSAPI_POSIX
    fftw_mpi_gather_wisdom(MPI_COMM_WORLD);
    {
      FILE *_wisdomFile = NULL;
      if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
        fftw_export_wisdom_to_file(_wisdomFile);
        fclose(_wisdomFile);
      }
    }
    #endif // POSIX
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  }
  
  if (_forward) {
    fftw_execute_r2r(
      _fftw_forward_plan,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in)
    );
  } else {
    fftw_execute_r2r(
      _fftw_backward_plan,
      reinterpret_cast<real*>(_data_in),
      reinterpret_cast<real*>(_data_in)
    );
  }
}


// In-place multiply
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  #pragma ivdep
  for (long _i0 = 0; _i0 < _prefix_lattice * _postfix_lattice; _i0++) {
    _data_in[_i0] *= _multiplier;
  }
}

// ********************************************************
//   Command line argument processing function implementations
void _print_usage()
{
  // This function does not return.
  _LOG(_NO_ERROR_TERMINATE_LOG_LEVEL, "\n\nUsage: dGPE_Dynamics --xmin <real> --xmax <real> --ymin <real> --ymax <real> --numGridPoints1 <integer> --numGridPoints2 <integer> --gamma0 <real>\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
                         "-x,  --xmin\treal \t\t-128.0\n"
                         "-m,  --xmax\treal \t\t128.0\n"
                         "-y,  --ymin\treal \t\t-128.0\n"
                         "-a,  --ymax\treal \t\t128.0\n"
                         "-n,  --numGridPoints1\tinteger \t\t256\n"
                         "-u,  --numGridPoints2\tinteger \t\t256\n"
                         "-g,  --gamma0\treal \t\t0.02\n"
                         );
  // _LOG terminates the simulation.
}

// ********************************************************
//   Distributed MPI Simulation Driver function implementations
void _segment0()
{
  
  
  uint32_t _gen_initial_noise_local_seeds[10] = {
  _gen_initial_noise_seeds[0]+(0 + _rank)*1,
  _gen_initial_noise_seeds[1]+(0 + _rank)*2,
  _gen_initial_noise_seeds[2]+(0 + _rank)*3,
  _gen_initial_noise_seeds[3]+(0 + _rank)*4,
  _gen_initial_noise_seeds[4]+(0 + _rank)*5,
  _gen_initial_noise_seeds[5]+(0 + _rank)*6,
  _gen_initial_noise_seeds[6]+(0 + _rank)*7,
  _gen_initial_noise_seeds[7]+(0 + _rank)*8,
  _gen_initial_noise_seeds[8]+(0 + _rank)*9,
  _gen_initial_noise_seeds[9]+(0 + _rank)*10
  };
  
  
  bzero(_gen_initial_noise, sizeof(_gen_initial_noise));
  for (unsigned long _i0=0; _i0<MIN(3, 10); _i0++)
    _gen_initial_noise[_i0] = (unsigned short)_gen_initial_noise_local_seeds[_i0];
  
  erand48(_gen_initial_noise);
  
  t = 0.0;
  
  _mg0_output_raw_initialise();
  _active_xy_init_wavefunction = _xy_init_wavefunction;
  _xy_init_wavefunction_initialise();
  _active_xy_potential = _xy_potential;
  _xy_potential_initialise();
  _active_xy_gainloss = _xy_gainloss;
  _xy_gainloss_initialise();
  _xy_initial_noise_evaluate();
  _active_xy_wavefunction = _xy_wavefunction;
  _xy_wavefunction_initialise();
  _mg0_output_index_t = 0;
  // Initialise child segments
  
  _xy_segment2_xy_operators_operator0_field = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_segment2_xy_operators_operator0_field_alloc_size,1));
  _active_xy_segment2_xy_operators_operator0_field = _xy_segment2_xy_operators_operator0_field;
  
  
  _xy_segment2_xy_operators_operator0_result = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_segment2_xy_operators_operator0_result_alloc_size,1));
  _active_xy_segment2_xy_operators_operator0_result = _xy_segment2_xy_operators_operator0_result;
  _segment2_akfield_xy_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_wavefunction_alloc_size,1));
  _segment2_aifield_xy_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_wavefunction_alloc_size,1));
  _segment2_ajfield_xy_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_wavefunction_alloc_size,1));
  _segment2_alfield_xy_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_wavefunction_alloc_size,1));
  _segment2_checkfield_xy_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_xy_wavefunction_alloc_size,1));
  _segment2_xy_operators_calculate_operator0_field();
  for (unsigned long _cycle = 0; _cycle < 1000; _cycle++) {
    _segment1();
    _segment2();
    _segment3();
  }
  // Finalise child segments
  
  xmds_free(_xy_segment2_xy_operators_operator0_field);
  _active_xy_segment2_xy_operators_operator0_field = _xy_segment2_xy_operators_operator0_field = NULL;
  
  
  xmds_free(_xy_segment2_xy_operators_operator0_result);
  _active_xy_segment2_xy_operators_operator0_result = _xy_segment2_xy_operators_operator0_result = NULL;
  xmds_free(_segment2_akfield_xy_wavefunction);
  xmds_free(_segment2_aifield_xy_wavefunction);
  xmds_free(_segment2_ajfield_xy_wavefunction);
  xmds_free(_segment2_alfield_xy_wavefunction);
  xmds_free(_segment2_checkfield_xy_wavefunction);
  
  _mg0_process();
}


// ********************************************************
//   field xy function implementations
// initialisation for vector init_wavefunction
void _xy_init_wavefunction_initialise()
{
  
  // HDF5 initialisation has three stages.
  // 1. Initialise the vector to zero.
  // 2. Execute any CDATA code if there is any.
  // 3. Read data from the HDF5 file.
  
  {
    // Stage 1 of initialisation
    bzero(_active_xy_init_wavefunction, sizeof(real) * _xy_init_wavefunction_alloc_size);
    // Stage 2 of initialisation
    long _xy_init_wavefunction_index_pointer = 0;
    #define phiR _active_xy_init_wavefunction[_xy_init_wavefunction_index_pointer + 0]
    #define phiI _active_xy_init_wavefunction[_xy_init_wavefunction_index_pointer + 1]
    #define x _x[_index_x + _local_unswapped_offset_x]
    #define dx (_dx * (1.0))
    
    for (long _index_x = 0; _index_x < _local_unswapped_lattice_x; _index_x++) {
      #define y _y[_index_y + 0]
      #define dy (_dy * (1.0))
      
      for (long _index_y = 0; _index_y < _lattice_y; _index_y++) {
        // Stage 2 of initialisation
        
        // The purpose of the following define is to give a (somewhat helpful) compile-time error
        // if the user has attempted to use the propagation dimension variable in the initialisation
        // block of a <vector> element. If they're trying to do this, what they really want is a 
        // <computed_vector> instead.
        #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
        
        // ********** Initialisation code ***************
        // **********************************************
        #undef t
        // Increment index pointers for vectors in field xy (or having the same dimensions)
        _xy_init_wavefunction_index_pointer += 1 * _xy_init_wavefunction_ncomponents;
        
      }
      #undef y
      #undef dy
    }
    #undef x
    #undef dx
    #undef phiR
    #undef phiI
  }
  
  htri_t result;
  hid_t hdf5_file = H5Fopen("Groundstate.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_ERROR_LOG_LEVEL, "Unable to open input HDF5 file 'Groundstate.h5'. Does it exist?\n");
  }
  hid_t hdf5_parent = 0;
  if ((result = H5Lexists(hdf5_file, "/1", H5P_DEFAULT)) > 0) {
    hdf5_parent = H5Gopen(hdf5_file, "/1");
  } else if (!result) {
    hdf5_parent = hdf5_file;
  } else {
    _LOG(_ERROR_LOG_LEVEL, "Unable to determine if group '/1' exists in HDF5 file 'Groundstate.h5'. Is the file corrupt?\n");
  }
  
  hsize_t file_dims[2];
  
  hid_t dataset_x;
  if ((result = H5Lexists(hdf5_parent, "x", H5P_DEFAULT))>0)
    dataset_x = H5Dopen(hdf5_parent, "x");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'x' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'x' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_x = H5Dget_space(dataset_x);
  file_dims[0] = H5Sget_simple_extent_npoints(dataspace_x);
  real* x_inputdata = (real*)xmds_malloc(file_dims[0] * sizeof(real));
  H5Dread(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, x_inputdata);
  for (long _i0 = 0; _i0 < _lattice_x-1; _i0++) {
    real step = _x[_i0+1] - _x[_i0];
    if (abs(_x[_i0] - x_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'x'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_x: %e, simulation_x: %e, difference: %e\n",
                             (real)x_inputdata[_i0], (real)_x[_i0], (real)x_inputdata[_i0] - _x[_i0]);
    }
  }
  hid_t dataset_y;
  if ((result = H5Lexists(hdf5_parent, "y", H5P_DEFAULT))>0)
    dataset_y = H5Dopen(hdf5_parent, "y");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'y' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'y' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_y = H5Dget_space(dataset_y);
  file_dims[1] = H5Sget_simple_extent_npoints(dataspace_y);
  real* y_inputdata = (real*)xmds_malloc(file_dims[1] * sizeof(real));
  H5Dread(dataset_y, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, y_inputdata);
  for (long _i0 = 0; _i0 < _lattice_y-1; _i0++) {
    real step = _y[_i0+1] - _y[_i0];
    if (abs(_y[_i0] - y_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'y'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_y: %e, simulation_y: %e, difference: %e\n",
                             (real)y_inputdata[_i0], (real)_y[_i0], (real)y_inputdata[_i0] - _y[_i0]);
    }
  }
  
  hid_t file_dataspace;
  file_dataspace = H5Screate_simple(2, file_dims, NULL);
  bool _variablesFound = false;
  hid_t dataset_phiR = 0;
  if ((result = H5Lexists(hdf5_parent, "phiR", H5P_DEFAULT))>0) {
    dataset_phiR = H5Dopen(hdf5_parent, "phiR");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'phiR' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'phiR' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataset_phiI = 0;
  if ((result = H5Lexists(hdf5_parent, "phiI", H5P_DEFAULT))>0) {
    dataset_phiI = H5Dopen(hdf5_parent, "phiI");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'phiI' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'phiI' exists in HDF5 file. Is the file corrupt?\n");
  
  if (!_variablesFound) {
    // We haven't found anything. There's a problem with the input file.
    _LOG(_ERROR_LOG_LEVEL, "Error: None of the variables were found in the HDF5 file. Please check the file.\n");
  }
  /* Create the data space */
  hsize_t file_start[2] = {(unsigned long long int)_local_unswapped_offset_x, (unsigned long long int)0};
  hsize_t mem_dims[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
  hsize_t mem_start[3] = {0, 0, 0};
  hsize_t mem_stride[3] = {1, 1, 1};
  hsize_t mem_count[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
  
  
  hid_t mem_dataspace;
  mem_dims[2] = 2;
  mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
  mem_stride[2] = 2;
  
  // Select hyperslabs of memory and file data spaces for data transfer operation
  mem_start[2] = 0;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_phiR)
    H5Dread(dataset_phiR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_init_wavefunction);
  mem_start[2] = 1;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_phiI)
    H5Dread(dataset_phiI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_init_wavefunction);
  
  H5Sclose(mem_dataspace);
  
  
  if (dataset_phiR) H5Dclose(dataset_phiR);
  if (dataset_phiI) H5Dclose(dataset_phiI);
  H5Sclose(file_dataspace);
  
  xmds_free(x_inputdata);
  H5Sclose(dataspace_x);
  H5Dclose(dataset_x);
  xmds_free(y_inputdata);
  H5Sclose(dataspace_y);
  H5Dclose(dataset_y);
  if (hdf5_parent != hdf5_file)
    H5Gclose(hdf5_parent);
  H5Fclose(hdf5_file);
}

void _xy_initial_noise_evaluate()
{
  const ptrdiff_t _vector_size = (_local_unswapped_lattice_x * _lattice_y) * _xy_initial_noise_ncomponents;
  const real _var = 1.0 / ((_dx * 1.0 * _dy * 1.0));
  
  const ptrdiff_t _evenNoises = _vector_size & ~1;
  for (ptrdiff_t _i0 = 0; _i0 < _evenNoises; _i0 += 2) {
    real _v1, _v2, _rsq;
    do {
      _v1 = 2.0*erand48(_gen_initial_noise) - 1.0;
      _v2 = 2.0*erand48(_gen_initial_noise) - 1.0;
      _rsq = _v1*_v1 + _v2*_v2;
    } while(_rsq >= 1.0 || _rsq == 0.0);
    const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
    reinterpret_cast<real*>(_active_xy_initial_noise)[_i0 + 0] = _v1*_fac;
    reinterpret_cast<real*>(_active_xy_initial_noise)[_i0 + 1] = _v2*_fac;
  }
  
  // If _n is odd, we need to generate the last random number
  if (_vector_size & 1) {
    static real _spareNoise = 0.0;
    static bool _spareNoiseAvailable = false;
    static real _old_var = 0.0;
    
    if (_spareNoiseAvailable && _old_var == _var) {
      reinterpret_cast<real*>(_active_xy_initial_noise)[_vector_size - 1] = _spareNoise;
      _spareNoiseAvailable = false;
    } else {
      real _v1, _v2, _rsq;
      do {
        _v1 = 2.0*erand48(_gen_initial_noise) - 1.0;
        _v2 = 2.0*erand48(_gen_initial_noise) - 1.0;
        _rsq = _v1*_v1 + _v2*_v2;
      } while(_rsq >= 1.0 || _rsq == 0.0);
      const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
      reinterpret_cast<real*>(_active_xy_initial_noise)[_vector_size - 1] = _v1*_fac;
      _spareNoise = _v2*_fac;
      
      _spareNoiseAvailable = true;
      _old_var = _var;
    }
  }
}

// initialisation for vector gainloss
void _xy_gainloss_initialise()
{
  
  // HDF5 initialisation has three stages.
  // 1. Initialise the vector to zero.
  // 2. Execute any CDATA code if there is any.
  // 3. Read data from the HDF5 file.
  
  {
    // Stage 1 of initialisation
    bzero(_active_xy_gainloss, sizeof(real) * _xy_gainloss_alloc_size);
    // Stage 2 of initialisation
    long _xy_gainloss_index_pointer = 0;
    #define V2 _active_xy_gainloss[_xy_gainloss_index_pointer + 0]
    #define loss _active_xy_gainloss[_xy_gainloss_index_pointer + 1]
    #define x _x[_index_x + _local_unswapped_offset_x]
    #define dx (_dx * (1.0))
    
    for (long _index_x = 0; _index_x < _local_unswapped_lattice_x; _index_x++) {
      #define y _y[_index_y + 0]
      #define dy (_dy * (1.0))
      
      for (long _index_y = 0; _index_y < _lattice_y; _index_y++) {
        // Stage 2 of initialisation
        
        // The purpose of the following define is to give a (somewhat helpful) compile-time error
        // if the user has attempted to use the propagation dimension variable in the initialisation
        // block of a <vector> element. If they're trying to do this, what they really want is a 
        // <computed_vector> instead.
        #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
        
        // ********** Initialisation code ***************
        // **********************************************
        #undef t
        // Increment index pointers for vectors in field xy (or having the same dimensions)
        _xy_gainloss_index_pointer += 1 * _xy_gainloss_ncomponents;
        
      }
      #undef y
      #undef dy
    }
    #undef x
    #undef dx
    #undef V2
    #undef loss
  }
  
  htri_t result;
  hid_t hdf5_file = H5Fopen("Losses.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_ERROR_LOG_LEVEL, "Unable to open input HDF5 file 'Losses.h5'. Does it exist?\n");
  }
  hid_t hdf5_parent = 0;
  if ((result = H5Lexists(hdf5_file, "/1", H5P_DEFAULT)) > 0) {
    hdf5_parent = H5Gopen(hdf5_file, "/1");
  } else if (!result) {
    hdf5_parent = hdf5_file;
  } else {
    _LOG(_ERROR_LOG_LEVEL, "Unable to determine if group '/1' exists in HDF5 file 'Losses.h5'. Is the file corrupt?\n");
  }
  
  hsize_t file_dims[2];
  
  hid_t dataset_x;
  if ((result = H5Lexists(hdf5_parent, "x", H5P_DEFAULT))>0)
    dataset_x = H5Dopen(hdf5_parent, "x");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'x' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'x' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_x = H5Dget_space(dataset_x);
  file_dims[0] = H5Sget_simple_extent_npoints(dataspace_x);
  real* x_inputdata = (real*)xmds_malloc(file_dims[0] * sizeof(real));
  H5Dread(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, x_inputdata);
  for (long _i0 = 0; _i0 < _lattice_x-1; _i0++) {
    real step = _x[_i0+1] - _x[_i0];
    if (abs(_x[_i0] - x_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'x'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_x: %e, simulation_x: %e, difference: %e\n",
                             (real)x_inputdata[_i0], (real)_x[_i0], (real)x_inputdata[_i0] - _x[_i0]);
    }
  }
  hid_t dataset_y;
  if ((result = H5Lexists(hdf5_parent, "y", H5P_DEFAULT))>0)
    dataset_y = H5Dopen(hdf5_parent, "y");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'y' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'y' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_y = H5Dget_space(dataset_y);
  file_dims[1] = H5Sget_simple_extent_npoints(dataspace_y);
  real* y_inputdata = (real*)xmds_malloc(file_dims[1] * sizeof(real));
  H5Dread(dataset_y, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, y_inputdata);
  for (long _i0 = 0; _i0 < _lattice_y-1; _i0++) {
    real step = _y[_i0+1] - _y[_i0];
    if (abs(_y[_i0] - y_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'y'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_y: %e, simulation_y: %e, difference: %e\n",
                             (real)y_inputdata[_i0], (real)_y[_i0], (real)y_inputdata[_i0] - _y[_i0]);
    }
  }
  
  hid_t file_dataspace;
  file_dataspace = H5Screate_simple(2, file_dims, NULL);
  bool _variablesFound = false;
  hid_t dataset_V2 = 0;
  if ((result = H5Lexists(hdf5_parent, "V2", H5P_DEFAULT))>0) {
    dataset_V2 = H5Dopen(hdf5_parent, "V2");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'V2' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'V2' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataset_loss = 0;
  if ((result = H5Lexists(hdf5_parent, "loss", H5P_DEFAULT))>0) {
    dataset_loss = H5Dopen(hdf5_parent, "loss");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'loss' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'loss' exists in HDF5 file. Is the file corrupt?\n");
  
  if (!_variablesFound) {
    // We haven't found anything. There's a problem with the input file.
    _LOG(_ERROR_LOG_LEVEL, "Error: None of the variables were found in the HDF5 file. Please check the file.\n");
  }
  /* Create the data space */
  hsize_t file_start[2] = {(unsigned long long int)_local_unswapped_offset_x, (unsigned long long int)0};
  hsize_t mem_dims[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
  hsize_t mem_start[3] = {0, 0, 0};
  hsize_t mem_stride[3] = {1, 1, 1};
  hsize_t mem_count[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
  
  
  hid_t mem_dataspace;
  mem_dims[2] = 2;
  mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
  mem_stride[2] = 2;
  
  // Select hyperslabs of memory and file data spaces for data transfer operation
  mem_start[2] = 0;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_V2)
    H5Dread(dataset_V2, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_gainloss);
  mem_start[2] = 1;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_loss)
    H5Dread(dataset_loss, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_gainloss);
  
  H5Sclose(mem_dataspace);
  
  
  if (dataset_V2) H5Dclose(dataset_V2);
  if (dataset_loss) H5Dclose(dataset_loss);
  H5Sclose(file_dataspace);
  
  xmds_free(x_inputdata);
  H5Sclose(dataspace_x);
  H5Dclose(dataset_x);
  xmds_free(y_inputdata);
  H5Sclose(dataspace_y);
  H5Dclose(dataset_y);
  if (hdf5_parent != hdf5_file)
    H5Gclose(hdf5_parent);
  H5Fclose(hdf5_file);
}

// initialisation for vector potential
void _xy_potential_initialise()
{
  
  // HDF5 initialisation has three stages.
  // 1. Initialise the vector to zero.
  // 2. Execute any CDATA code if there is any.
  // 3. Read data from the HDF5 file.
  
  {
    // Stage 1 of initialisation
    bzero(_active_xy_potential, sizeof(real) * _xy_potential_alloc_size);
    // Stage 2 of initialisation
    long _xy_potential_index_pointer = 0;
    #define V _active_xy_potential[_xy_potential_index_pointer + 0]
    #define x _x[_index_x + _local_unswapped_offset_x]
    #define dx (_dx * (1.0))
    
    for (long _index_x = 0; _index_x < _local_unswapped_lattice_x; _index_x++) {
      #define y _y[_index_y + 0]
      #define dy (_dy * (1.0))
      
      for (long _index_y = 0; _index_y < _lattice_y; _index_y++) {
        // Stage 2 of initialisation
        
        // The purpose of the following define is to give a (somewhat helpful) compile-time error
        // if the user has attempted to use the propagation dimension variable in the initialisation
        // block of a <vector> element. If they're trying to do this, what they really want is a 
        // <computed_vector> instead.
        #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
        
        // ********** Initialisation code ***************
        // **********************************************
        #undef t
        // Increment index pointers for vectors in field xy (or having the same dimensions)
        _xy_potential_index_pointer += 1 * _xy_potential_ncomponents;
        
      }
      #undef y
      #undef dy
    }
    #undef x
    #undef dx
    #undef V
  }
  
  htri_t result;
  hid_t hdf5_file = H5Fopen("Potential.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_ERROR_LOG_LEVEL, "Unable to open input HDF5 file 'Potential.h5'. Does it exist?\n");
  }
  hid_t hdf5_parent = 0;
  if ((result = H5Lexists(hdf5_file, "/1", H5P_DEFAULT)) > 0) {
    hdf5_parent = H5Gopen(hdf5_file, "/1");
  } else if (!result) {
    hdf5_parent = hdf5_file;
  } else {
    _LOG(_ERROR_LOG_LEVEL, "Unable to determine if group '/1' exists in HDF5 file 'Potential.h5'. Is the file corrupt?\n");
  }
  
  hsize_t file_dims[2];
  
  hid_t dataset_x;
  if ((result = H5Lexists(hdf5_parent, "x", H5P_DEFAULT))>0)
    dataset_x = H5Dopen(hdf5_parent, "x");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'x' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'x' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_x = H5Dget_space(dataset_x);
  file_dims[0] = H5Sget_simple_extent_npoints(dataspace_x);
  real* x_inputdata = (real*)xmds_malloc(file_dims[0] * sizeof(real));
  H5Dread(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, x_inputdata);
  for (long _i0 = 0; _i0 < _lattice_x-1; _i0++) {
    real step = _x[_i0+1] - _x[_i0];
    if (abs(_x[_i0] - x_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'x'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_x: %e, simulation_x: %e, difference: %e\n",
                             (real)x_inputdata[_i0], (real)_x[_i0], (real)x_inputdata[_i0] - _x[_i0]);
    }
  }
  hid_t dataset_y;
  if ((result = H5Lexists(hdf5_parent, "y", H5P_DEFAULT))>0)
    dataset_y = H5Dopen(hdf5_parent, "y");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'y' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'y' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_y = H5Dget_space(dataset_y);
  file_dims[1] = H5Sget_simple_extent_npoints(dataspace_y);
  real* y_inputdata = (real*)xmds_malloc(file_dims[1] * sizeof(real));
  H5Dread(dataset_y, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, y_inputdata);
  for (long _i0 = 0; _i0 < _lattice_y-1; _i0++) {
    real step = _y[_i0+1] - _y[_i0];
    if (abs(_y[_i0] - y_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'y'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_y: %e, simulation_y: %e, difference: %e\n",
                             (real)y_inputdata[_i0], (real)_y[_i0], (real)y_inputdata[_i0] - _y[_i0]);
    }
  }
  
  hid_t file_dataspace;
  file_dataspace = H5Screate_simple(2, file_dims, NULL);
  bool _variablesFound = false;
  hid_t dataset_V = 0;
  if ((result = H5Lexists(hdf5_parent, "V", H5P_DEFAULT))>0) {
    dataset_V = H5Dopen(hdf5_parent, "V");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'V' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'V' exists in HDF5 file. Is the file corrupt?\n");
  
  if (!_variablesFound) {
    // We haven't found anything. There's a problem with the input file.
    _LOG(_ERROR_LOG_LEVEL, "Error: None of the variables were found in the HDF5 file. Please check the file.\n");
  }
  /* Create the data space */
  hsize_t file_start[2] = {(unsigned long long int)_local_unswapped_offset_x, (unsigned long long int)0};
  hsize_t mem_dims[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
  hsize_t mem_start[3] = {0, 0, 0};
  hsize_t mem_stride[3] = {1, 1, 1};
  hsize_t mem_count[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
  
  
  hid_t mem_dataspace;
  mem_dims[2] = 1;
  mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
  mem_stride[2] = 1;
  
  // Select hyperslabs of memory and file data spaces for data transfer operation
  mem_start[2] = 0;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_V)
    H5Dread(dataset_V, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_potential);
  
  H5Sclose(mem_dataspace);
  
  
  if (dataset_V) H5Dclose(dataset_V);
  H5Sclose(file_dataspace);
  
  xmds_free(x_inputdata);
  H5Sclose(dataspace_x);
  H5Dclose(dataset_x);
  xmds_free(y_inputdata);
  H5Sclose(dataspace_y);
  H5Dclose(dataset_y);
  if (hdf5_parent != hdf5_file)
    H5Gclose(hdf5_parent);
  H5Fclose(hdf5_file);
}

// initialisation for computed vector kinetic
void _xy_kinetic_initialise()
{
  
  _xy_kinetic_basis = 0;
}


void _xy_kinetic_basis_transform(ptrdiff_t new_basis)
{
  if (_xy_kinetic_basis == new_basis)
    return;
  
  if (_xy_kinetic_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'xy_kinetic' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_xy_kinetic_basis_map.count(_basis_pair(_xy_kinetic_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'xy_kinetic' from basis %s to basis %s.\n",
      _basis_identifiers[_xy_kinetic_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _xy_kinetic_basis_map[_basis_pair(_xy_kinetic_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'xy_kinetic' from basis %s to basis %s.\n",
                           _basis_identifiers[_xy_kinetic_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_xy_kinetic);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _xy_kinetic_basis = new_basis;
}


void _xy_kinetic_evaluate()
{
  // Transforming vectors to basis (distributed ky, kx)
  _xy_wavefunction_basis_transform(0); // (distributed ky, kx)
  
  long _xy_kinetic_index_pointer = 0;
  #define KE _active_xy_kinetic[_xy_kinetic_index_pointer + 0]
  long _xy_wavefunction_index_pointer = 0;
  #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
  #define ky _ky[_index_ky + _local_swapped_offset_ky]
  #define dky (_dky * (1.0))
  
  for (long _index_ky = 0; _index_ky < _local_swapped_lattice_ky; _index_ky++) {
    #define kx _kx[_index_kx + 0]
    #define dkx (_dkx * (1.0))
    
    for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
      // ************* Evaluation code ****************
      #line 104 "./Dynamics.xml"
      
      KE =  0.5*(kx*kx+ky*ky)*phi;
      
      #line 1921 "dGPE_Dynamics.cc"
      // **********************************************
      // Increment index pointers for vectors in field xy (or having the same dimensions)
      _xy_kinetic_index_pointer += 1 * _xy_kinetic_ncomponents;
      _xy_wavefunction_index_pointer += 1 * _xy_wavefunction_ncomponents;
      
    }
    #undef kx
    #undef dkx
  }
  #undef ky
  #undef dky
  #undef KE
  #undef phi
  
  _xy_kinetic_basis = 0;
}

// initialisation for vector wavefunction
void _xy_wavefunction_initialise()
{
  
  long _xy_init_wavefunction_index_pointer = 0;
  #define phiR _active_xy_init_wavefunction[_xy_init_wavefunction_index_pointer + 0]
  #define phiI _active_xy_init_wavefunction[_xy_init_wavefunction_index_pointer + 1]
  long _xy_initial_noise_index_pointer = 0;
  #define fuzz1 _active_xy_initial_noise[_xy_initial_noise_index_pointer + 0]
  #define fuzz2 _active_xy_initial_noise[_xy_initial_noise_index_pointer + 1]
  long _xy_wavefunction_index_pointer = 0;
  #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
  #define x _x[_index_x + _local_unswapped_offset_x]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _local_unswapped_lattice_x; _index_x++) {
    #define y _y[_index_y + 0]
    #define dy (_dy * (1.0))
    
    for (long _index_y = 0; _index_y < _lattice_y; _index_y++) {
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      #line 93 "./Dynamics.xml"
      
      phi = phiR + i*phiI;
      phi += 1e-3*(fuzz1 + i*fuzz2);
      
      #line 1971 "dGPE_Dynamics.cc"
      // **********************************************
      #undef t
      
      // Increment index pointers for vectors in field xy (or having the same dimensions)
      _xy_init_wavefunction_index_pointer += 1 * _xy_init_wavefunction_ncomponents;
      _xy_initial_noise_index_pointer += 1 * _xy_initial_noise_ncomponents;
      _xy_wavefunction_index_pointer += 1 * _xy_wavefunction_ncomponents;
      
    }
    #undef y
    #undef dy
  }
  #undef x
  #undef dx
  #undef phiR
  #undef phiI
  #undef fuzz1
  #undef fuzz2
  #undef phi
  
  _xy_wavefunction_basis = 1;
}


void _xy_wavefunction_basis_transform(ptrdiff_t new_basis)
{
  if (_xy_wavefunction_basis == new_basis)
    return;
  
  if (_xy_wavefunction_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'xy_wavefunction' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_xy_wavefunction_basis_map.count(_basis_pair(_xy_wavefunction_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'xy_wavefunction' from basis %s to basis %s.\n",
      _basis_identifiers[_xy_wavefunction_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _xy_wavefunction_basis_map[_basis_pair(_xy_wavefunction_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'xy_wavefunction' from basis %s to basis %s.\n",
                           _basis_identifiers[_xy_wavefunction_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_xy_wavefunction);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _xy_wavefunction_basis = new_basis;
}

// ********************************************************
//   segment 1 (Filter) function implementations
void _segment1()
{
  
  // Filter operator
  _segment1__evaluate_operator0();
}

// Filter operator
void _segment1__evaluate_operator0()
{
  
  // ************** Filter code *****************
   printf("Hello world from a filter segment!\n");  // **********************************************
}

// ********************************************************
//   segment 2 (RK45 adaptive-step integrator) function implementations
void _segment2()
{
  real _step = 10/(real)2000;
  real _old_step = _step;
  real _min_step = _step;
  real _max_step = _step;
  long _attempted_steps = 0;
  long _unsuccessful_steps = 0;
  
  real _tolerance = 1e-06;
  
  real _error, _last_norm_error = 1.0;
  real _segment2_xy_wavefunction_error;
  
  bool _discard = false;
  bool _break_next = false;
  
  bool _next_sample_flag[3];
  for (long _i0 = 0; _i0 < 3; _i0++)
    _next_sample_flag[_i0] = false;
  
  long _next_sample_counter[1];
  for (long _i0 = 0; _i0 < 1; _i0++)
    _next_sample_counter[_i0] = 1;
  
  real _t_local = 0.0;
  
  real _t_break_next = _segment2_setup_sampling(_next_sample_flag, _next_sample_counter);
  
  if ( (_t_local + _step)*(1.0 + _EPSILON) >= _t_break_next) {
    _break_next = true;
    _step = _t_break_next - _t_local;
  }
  
  complex* _akfield_xy_wavefunction = _segment2_akfield_xy_wavefunction;
  complex* _aifield_xy_wavefunction = _segment2_aifield_xy_wavefunction;
  complex* _ajfield_xy_wavefunction = _segment2_ajfield_xy_wavefunction;
  complex* _alfield_xy_wavefunction = _segment2_alfield_xy_wavefunction;
  complex* _checkfield_xy_wavefunction = _segment2_checkfield_xy_wavefunction;
  
  
  // Cash-Karp coefficients
  real _a_raw[7];
  real _a[7];
  real _b[7][7];
  real _c[7];
  real _cs[7];
  // linear combinations for the (k_i)s
  real _d[4];
  real _e[5];
  real _f[6];
  real _g[7];
  
  _a_raw[0]=0.0;
  _a_raw[1]=0.0;
  _a_raw[2]=1.0/5;
  _a_raw[3]=3.0/10;
  _a_raw[4]=3.0/5;
  _a_raw[5]=1.0;
  _a_raw[6]=7.0/8.0;
  
  _a[0]=0.0;
  _a[1]=0.0;
  for(long _i0 = 2; _i0 < 7; _i0++)
    _a[_i0] = _a_raw[_i0] - _a_raw[_i0-1];
  
  _b[2][1]=1.0/5;
  _b[3][1]=3.0/40;
  _b[3][2]=9.0/40;
  _b[4][1]=3.0/10;
  _b[4][2]=-9.0/10;
  _b[4][3]=6.0/5;
  _b[5][1]=-11.0/54;
  _b[5][2]=5.0/2;
  _b[5][3]=-70.0/27;
  _b[5][4]=35.0/27;
  _b[6][1]=1631.0/55296;
  _b[6][2]=175.0/512;
  _b[6][3]=575.0/13824;
  _b[6][4]=44275.0/110592;
  _b[6][5]=253.0/4096;
  
  _c[0]=0.0;
  _c[1]=37.0/378;
  _c[2]=0.0;
  _c[3]=250.0/621;
  _c[4]=125.0/594;
  _c[5]=0.0;
  _c[6]=512.0/1771;
  
  _cs[0]=0.0;
  _cs[1]=2825.0/27648;
  _cs[2]=0.0;
  _cs[3]=18575.0/48384;
  _cs[4]=13525.0/55296;
  _cs[5]=277.0/14336;
  _cs[6]=1.0/4;
  
  _d[0]=0.0;
  _d[1]=1.0-_b[3][1]/_c[1];
  _d[2]=_b[3][1]/_c[1];
  _d[3]=_b[3][2];
  
  _e[0]=0.0;
  _e[1]=1.0-_b[4][1]/_c[1];
  _e[2]=_b[4][1]/_c[1];
  _e[3]=_b[4][2];
  _e[4]=_b[4][3];
  
  _f[0]=0.0;
  _f[1]=1.0-_b[5][1]/_c[1];
  _f[2]=_b[5][1]/_c[1];
  _f[3]=_b[5][2];
  _f[4]=_b[5][3]-_b[5][1]/_c[1]*_c[3];
  _f[5]=_b[5][4]-_b[5][1]/_c[1]*_c[4];
  
  real _den=_c[1]*_cs[4]-_cs[1]*_c[4];
  _g[0]=0.0;
  _g[1]=( _b[6][4]*(_cs[1]-_c[1]) + _b[6][1]*(_c[4]-_cs[4]) )/_den + 1.0;
  _g[2]=  _b[6][2];
  _g[3]=( _b[6][4]*(_cs[1]*_c[3] - _c[1]*_cs[3]) + _b[6][1]*(_cs[3]*_c[4] - _c[3]*_cs[4]) )/_den + _b[6][3];
  _g[4]=( _b[6][1]*_cs[4]-_b[6][4]*_cs[1] )/_den;
  _g[5]=  _b[6][5] + _cs[5]*( _b[6][1]*_c[4]-_b[6][4]*_c[1] )/_den;
  _g[6]=( -_b[6][1]*_c[4]+_b[6][4]*_c[1] )/_den;
  
  do {
    
    do {
      
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      // a_k = y1
      memcpy(_akfield_xy_wavefunction, _xy_wavefunction, sizeof(complex) * _xy_wavefunction_alloc_size);
      
      _segment2_calculate_nonconstant_ip_fields(_step, 1);
      
      // a_i = D(a_2*dt)[y1]
      _segment2_ip_evolve(1);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      // y2 = y1
      memcpy(_checkfield_xy_wavefunction, _xy_wavefunction, sizeof(complex) * _xy_wavefunction_alloc_size);
      
      // a_i = y1
      memcpy(_aifield_xy_wavefunction, _xy_wavefunction, sizeof(complex) * _xy_wavefunction_alloc_size);
      
      _active_xy_wavefunction = _akfield_xy_wavefunction;
      
      // a_k = G[a_k, t]
      _segment2_calculate_delta_a(_step);
      
      // a_k = D(a_2*dt)[a_k]
      _segment2_ip_evolve(1);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_xy_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents; _i0++) {
          // y1 = y1 + c_1*a_k
          _AUTOVEC(_xy_wavefunction)[_i0] += _c[1]*_AUTOVEC(_akfield_xy_wavefunction)[_i0];
          // y2 = y2 + cs_1*a_k
          _AUTOVEC(_checkfield_xy_wavefunction)[_i0] += _cs[1]*_AUTOVEC(_akfield_xy_wavefunction)[_i0];
          // a_k = a_i + b_21*a_k
          _AUTOVEC(_akfield_xy_wavefunction)[_i0] = _AUTOVEC(_aifield_xy_wavefunction)[_i0] + _b[2][1]*_AUTOVEC(_akfield_xy_wavefunction)[_i0];
        }
      
      }
      
      t += _a[2] * _step;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 2);
      
      _segment2_ip_evolve(-2);
      
      // a_k = G[a_k, t + aa_2*dt]
      _segment2_calculate_delta_a(_step);
      
      _segment2_ip_evolve(2);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      // c_2 == cs_2 == 0
      {
        _MAKE_AUTOVEC_VARIABLE(_akfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_ajfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_xy_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents; _i0++) {
          // a_j = d_1*a_i + d_2*y1 + d_3*a_k
          _AUTOVEC(_ajfield_xy_wavefunction)[_i0] = _d[1]*_AUTOVEC(_aifield_xy_wavefunction)[_i0] + _d[2]*_AUTOVEC(_xy_wavefunction)[_i0] + _d[3]*_AUTOVEC(_akfield_xy_wavefunction)[_i0];
        }
      
      }
      
      t += _a[3] * _step;
      
      _active_xy_wavefunction = _ajfield_xy_wavefunction;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 3);
      
      // a_j = D((a_3 - a_2)*dt)[a_j]
      _segment2_ip_evolve(-3);
      
      // a_j = G[a_j, t + aa_3*dt]
      _segment2_calculate_delta_a(_step);
      
      // a_j = D(-(a_3 - a_2)*dt)[a_j]
      _segment2_ip_evolve(3);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_xy_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents; _i0++) {
          // a_l = e_1*a_i + e_2*y1 + e_3*a_k + e_4*a_j
          _AUTOVEC(_alfield_xy_wavefunction)[_i0] = _e[1]*_AUTOVEC(_aifield_xy_wavefunction)[_i0] + _e[2]*_AUTOVEC(_xy_wavefunction)[_i0] + _e[3]*_AUTOVEC(_akfield_xy_wavefunction)[_i0] + _e[4]*_AUTOVEC(_ajfield_xy_wavefunction)[_i0];
          // y1 = y1 + c_3*a_j
          _AUTOVEC(_xy_wavefunction)[_i0] += _c[3]*_AUTOVEC(_ajfield_xy_wavefunction)[_i0];
          // y2 = y2 + cs_3*a_j
          _AUTOVEC(_checkfield_xy_wavefunction)[_i0] += _cs[3]*_AUTOVEC(_ajfield_xy_wavefunction)[_i0];
        }
      
      }
      
      t += _a[4] * _step;
      
      _active_xy_wavefunction = _alfield_xy_wavefunction;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 4);
      
      // a_l = D((a_4 - a_2)*dt)[a_l]
      _segment2_ip_evolve(-4);
      
      // a_l = G[a_l, t + aa_4*dt]
      _segment2_calculate_delta_a(_step);
      
      // a_l = D(-(a_4 - a_2)*dt)[a_l]
      _segment2_ip_evolve(4);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_xy_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents; _i0++) {
          // y1 = y1 + c_4*a_l
          _AUTOVEC(_xy_wavefunction)[_i0] += _c[4]*_AUTOVEC(_alfield_xy_wavefunction)[_i0];
          // y2 = y2 + cs_4*a_l
          _AUTOVEC(_checkfield_xy_wavefunction)[_i0] += _cs[4]*_AUTOVEC(_alfield_xy_wavefunction)[_i0];
          // a_l = f_1*a_i + f_2*y1 + f_3*a_k + f_4*a_j + f_5*a_l
          _AUTOVEC(_alfield_xy_wavefunction)[_i0] = _f[1]*_AUTOVEC(_aifield_xy_wavefunction)[_i0] + _f[2]*_AUTOVEC(_xy_wavefunction)[_i0] + _f[3]*_AUTOVEC(_akfield_xy_wavefunction)[_i0] + _f[4]*_AUTOVEC(_ajfield_xy_wavefunction)[_i0] + _f[5]*_AUTOVEC(_alfield_xy_wavefunction)[_i0];
        }
      
      }
      
      t += _a[5] * _step;
      
      // a_l = G[a_l, t + aa_5*dt]
      _segment2_calculate_delta_a(_step);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      // c_5 == 0
      {
        _MAKE_AUTOVEC_VARIABLE(_ajfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_aifield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_checkfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_xy_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents; _i0++) {
          // y2 = y2 + cs_5*a_l
          _AUTOVEC(_checkfield_xy_wavefunction)[_i0] += _cs[5]*_AUTOVEC(_alfield_xy_wavefunction)[_i0];
          // a_l = g_1*a_i + g_2*a_k + g_3*a_j + g_4*y_1 + g_5*a_l + g_6*y2
          _AUTOVEC(_alfield_xy_wavefunction)[_i0] = _g[1]*_AUTOVEC(_aifield_xy_wavefunction)[_i0] + _g[2]*_AUTOVEC(_akfield_xy_wavefunction)[_i0] + _g[3]*_AUTOVEC(_ajfield_xy_wavefunction)[_i0] + _g[4]*_AUTOVEC(_xy_wavefunction)[_i0] + _g[5]*_AUTOVEC(_alfield_xy_wavefunction)[_i0] + _g[6]*_AUTOVEC(_checkfield_xy_wavefunction)[_i0];
        }
      
      }
      
      t += _a[6] * _step;
      
      _segment2_calculate_nonconstant_ip_fields(_step, 5);
      
      // a_l = D((a_6 - a_2)*dt)[a_l]
      _segment2_ip_evolve(-5);
      
      // a_l = G[a_l, t + aa_6*dt]
      _segment2_calculate_delta_a(_step);
      
      // a_l = D(-(a_6 - a_2)*dt)[a_l]
      _segment2_ip_evolve(5);
      _xy_wavefunction_basis_transform(1); // (distributed x, y)
      
      // c_5 == 0
      {
        _MAKE_AUTOVEC_VARIABLE(_checkfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_alfield_xy_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_xy_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents; _i0++) {
          // y1 = y1 + c_6*a_l
          _AUTOVEC(_xy_wavefunction)[_i0] += _c[6]*_AUTOVEC(_alfield_xy_wavefunction)[_i0];
          // y2 = y2 + cs_6*a_l
          _AUTOVEC(_checkfield_xy_wavefunction)[_i0] += _cs[6]*_AUTOVEC(_alfield_xy_wavefunction)[_i0];
        }
      
      }
      
      // t -> t + dt
      t -= _a[6]*_step;
      
      _active_xy_wavefunction = _checkfield_xy_wavefunction;
      
      _active_xy_wavefunction = _xy_wavefunction;
      
      
      
      _error = 0.0;
      
      _segment2_xy_wavefunction_error = _segment2_xy_wavefunction_timestep_error(_checkfield_xy_wavefunction);
      if (_segment2_xy_wavefunction_error > _error)
        _error = _segment2_xy_wavefunction_error;
      
      _attempted_steps++;
      
      if (_error < _tolerance) {
        _t_local += _step;
        if (_step > _max_step)
          _max_step = _step;
        if (!_break_next && _step < _min_step)
          _min_step = _step;
        _discard = false;
      } else {
        if (_error == 2.0*1e-06)
          _LOG(_SEGMENT_LOG_LEVEL, "NaN hit on this step. Retrying. (Error set to %e)\n", 2.0*1e-06);
        _LOG(_SEGMENT_LOG_LEVEL, "Step size %e failed, t = %e, error = %e\n", _step, t, _error);
        t -= _step;
  
        if (_segment2_xy_wavefunction_reset(_aifield_xy_wavefunction) == false) {
  
          _LOG(_WARNING_LOG_LEVEL, "WARNING: NaN present. Integration halted at t = %e.\n"
                             "         Non-finite number in integration vector \"wavefunction\" in segment 2.\n", t);
          if (_mg0_output_index_t < _mg0_output_lattice_t)
            _mg0_sample();
          
          goto _SEGMENT2_END;
        }
  
        _segment2_ip_evolve(-1);
        
        _discard = true;
        _break_next = false;
        _unsuccessful_steps++;
      }
      
      _old_step = _step;
      
      // Resize step
      if (_error < 0.5*_tolerance || _error > _tolerance) {
        const real _safetyFactor = 0.90;
        real _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-0.7/5.0)) * pow(_last_norm_error, real(0.4/5.0));
        _scalingFactor = MAX(_scalingFactor, 1.0/5.0);
        _scalingFactor = MIN(_scalingFactor, 7.0);
        if (_error > _tolerance && _scalingFactor > 1.0) {
          // If our step failed don't try and increase our step size. That would be silly.
          _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-1.0/5.0));
        }
        _old_step = _step;
        _last_norm_error = pow(_safetyFactor/_scalingFactor*pow(_last_norm_error, real(0.4/5.0)), real(5.0/0.7));
        _step *= _scalingFactor;
      }
      
    } while (_discard);
    
    if (_break_next) {
      if (_next_sample_flag[0]) {
        _mg0_sample();
        _next_sample_counter[0]++;
      }
      if (_next_sample_flag[1])
        _next_sample_flag[2] = true;
      else {
        _break_next = false;
        _t_break_next = _segment2_setup_sampling(_next_sample_flag, _next_sample_counter);
      }
    }
    
    if ( (_t_local + _step)*(1.0 + _EPSILON) > _t_break_next) {
      _break_next = true;
      _LOG(_SAMPLE_LOG_LEVEL, "Current timestep: %e\n", _old_step);
      _step = _t_break_next - _t_local;
    }
  } while (!_next_sample_flag[2]);
  
  _SEGMENT2_END:;
  
  _LOG(_SEGMENT_LOG_LEVEL, "Segment 2: minimum timestep: %e maximum timestep: %e\n", _min_step, _max_step);
  _LOG(_SEGMENT_LOG_LEVEL, "  Attempted %li steps, %.2f%% steps failed.\n", _attempted_steps, (100.0*_unsuccessful_steps)/_attempted_steps);
}


inline void _segment2_calculate_delta_a(real _step)
{
  _xy_kinetic_evaluate();
  
  // EX transverse derivative operator for field xy
  _segment2_xy_operators_evaluate_operator0();
  
  // Delta A propagation operator for field xy
  _segment2_xy_operators_evaluate_operator1(_step);
  
}


inline void _segment2_ip_evolve(int _exponent)
{
}


inline void _segment2_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}
real _segment2_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter)
{
  // The numbers of the moment groups that need to be sampled at the next sampling point.
  // An entry of N+1 means "reached end of integration interval"
  long _momentGroupNumbersNeedingSamplingNext[2];
  long _numberOfMomentGroupsToBeSampledNext = 1;
  
  long _previous_m = 1;
  long _previous_M = 1;
  
  real _t_break_next = (real)10;
  _momentGroupNumbersNeedingSamplingNext[0] = 1;
  
  // initialise all flags to false
  for (long _i0 = 0; _i0 < 2; _i0++)
    _next_sample_flag[_i0] = false;
  
  /* Check if moment group needs sampling at the same time as another already discovered sample (or the final time).
   * If so, add this moment group to the to-be-sampled list. If moment group demands sampling earlier than all
   * previously noted moment groups, erase all previous ones from list and set the sample time to this earlier one.
   */
  if (_next_sample_counter[0] * _previous_M == _previous_m * 1) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 0;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[0] * _previous_M < _previous_m * 1) {
    _t_break_next = _next_sample_counter[0] * ((real)10) / ((real)1);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 0;
    _previous_M = 1;
    _previous_m = _next_sample_counter[0];
  }
  
  // _momentGroupNumbersNeedingSamplingNext now contains the complete list of moment groups that need
  // to be sampled at the next sampling point. Set their flags to true.
  for (long _i0 = 0; _i0 < _numberOfMomentGroupsToBeSampledNext; _i0++)
    _next_sample_flag[_momentGroupNumbersNeedingSamplingNext[_i0]] = true;
  
  return _t_break_next;
}

real _segment2_xy_wavefunction_timestep_error(complex* _checkfield)
{
  real _error = 1e-24;
  real _temp_error = 0.0;
  real _temp_mod = 0.0;

  real _component_errors[_xy_wavefunction_ncomponents];
  for (long _i0 = 0; _i0 < _xy_wavefunction_ncomponents; _i0++)
    _component_errors[_i0] = 0.0;
  
  // Find the peak value for each component of the field
  real _cutoff[_xy_wavefunction_ncomponents];
  
  for (long _i0 = 0; _i0 < _xy_wavefunction_ncomponents; _i0++)
    _cutoff[_i0] = 0.0;
  
  {
    long _xy_wavefunction_index_pointer = 0;
    #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_local_unswapped_lattice_x * _lattice_y); _i0++) {
      for (long _i1 = 0; _i1 < _xy_wavefunction_ncomponents; _i1++) {
        _temp_mod = mod2(_xy_wavefunction[_xy_wavefunction_index_pointer + _i1]);
        if (_xmds_isnonfinite(_temp_mod))
          _cutoff[_i1] = INFINITY;
        else if (_cutoff[_i1] < _temp_mod)
          _cutoff[_i1] = _temp_mod;
      }
    
      _xy_wavefunction_index_pointer += _xy_wavefunction_ncomponents;
    }
    #undef phi
  }
  MPI_Allreduce(MPI_IN_PLACE, _cutoff, _xy_wavefunction_ncomponents, MPI_REAL, MPI_MAX, MPI_COMM_WORLD);
  
  for (long _i0 = 0; _i0 < _xy_wavefunction_ncomponents; _i0++) {
    if (_xmds_isnonfinite(_cutoff[_i0]))
      // Return an error two times the tolerance in this case because the timestep must be reduced.
      return 2.0*1e-06;
    _cutoff[_i0] *= 0.001;
    _cutoff[_i0] *= 0.001;
  }
  
  {
    long _xy_wavefunction_index_pointer = 0;
    #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_local_unswapped_lattice_x * _lattice_y); _i0++) {
      for (long  _i1 = 0; _i1 < _xy_wavefunction_ncomponents; _i1++) {
        if (mod2(_xy_wavefunction[_xy_wavefunction_index_pointer + _i1]) > _cutoff[_i1]) {
          _temp_error = abs(_xy_wavefunction[_xy_wavefunction_index_pointer + _i1] - _checkfield[_xy_wavefunction_index_pointer + _i1]) / (0.5*abs(_xy_wavefunction[_xy_wavefunction_index_pointer + _i1]) + 0.5*abs(_checkfield[_xy_wavefunction_index_pointer + _i1]));
          
          if (_xmds_isnonfinite(_temp_error)) {
            /* For _temp_error to be NaN, both the absolute value of the higher and lower order solutions
               must BOTH be zero. This therefore implies that their difference is zero, and that there is no error. */
            _temp_error = 0.0;
          }
          
          if (_error < _temp_error) // UNVECTORISABLE
            _error = _temp_error;
          if (_temp_error > _component_errors[_i1])
            _component_errors[_i1] = _temp_error;
        }
      }
    
      _xy_wavefunction_index_pointer += _xy_wavefunction_ncomponents;
    }
    #undef phi
  }
  MPI_Allreduce(MPI_IN_PLACE, &_error, 1, MPI_REAL, MPI_MAX, MPI_COMM_WORLD);
  MPI_Allreduce(MPI_IN_PLACE, _component_errors, _xy_wavefunction_ncomponents, MPI_REAL, MPI_MAX, MPI_COMM_WORLD);
  if (_error > 1e-06)
    _LOG(_WARNING_LOG_LEVEL, "phi_error: %.1e (cutoff: %.1e)\n",
                             _component_errors[0], _cutoff[0]);
  
  return _error;
}

bool _segment2_xy_wavefunction_reset(complex* _reset_to_xy_wavefunction)
{
  memcpy(_xy_wavefunction, _reset_to_xy_wavefunction, sizeof(complex) * _xy_wavefunction_alloc_size);
  
  /* return false if there's a NaN somewhere in the vector, otherwise return true */
  bool bNoNaNsPresent = true;
  {
    long _xy_wavefunction_index_pointer = 0;
    #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_local_unswapped_lattice_x * _lattice_y); _i0++) {
        for (long _i1 = 0; _i1 < _xy_wavefunction_ncomponents; _i1++) {
          if (_xmds_isnonfinite(_xy_wavefunction[_xy_wavefunction_index_pointer + _i1].Re())
            || _xmds_isnonfinite(_xy_wavefunction[_xy_wavefunction_index_pointer + _i1].Im())) bNoNaNsPresent = false;
        }
    
      _xy_wavefunction_index_pointer += _xy_wavefunction_ncomponents;
    }
    #undef phi
  }
  return bNoNaNsPresent;
}

// EX transverse derivative operator for field xy
void _segment2_xy_operators_evaluate_operator0()
{
  memcpy(_active_xy_segment2_xy_operators_operator0_result, _active_xy_wavefunction, _xy_wavefunction_alloc_size * sizeof(complex));
  complex *__backup_ptr = _active_xy_wavefunction;
  ptrdiff_t __backup_basis = _xy_wavefunction_basis;
  _active_xy_wavefunction = _active_xy_segment2_xy_operators_operator0_result;
  
  _xy_wavefunction_basis_transform(0); // (distributed ky, kx)
  
  long _xy_segment2_xy_operators_operator0_field_index_pointer = 0;
  #define T _active_xy_segment2_xy_operators_operator0_field[_xy_segment2_xy_operators_operator0_field_index_pointer + 0]
  
  long _xy_segment2_xy_operators_operator0_result_index_pointer = 0;
  #define _T_phi _active_xy_segment2_xy_operators_operator0_result[_xy_segment2_xy_operators_operator0_result_index_pointer + 0]
  
  long _xy_wavefunction_index_pointer = 0;
  #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
  for (long _i0 = 0; _i0 < (_local_swapped_lattice_ky * _lattice_kx); _i0++) {
    // T[phi]
    _T_phi = T * phi;
  
    _xy_segment2_xy_operators_operator0_field_index_pointer += _xy_segment2_xy_operators_operator0_field_ncomponents;
    _xy_segment2_xy_operators_operator0_result_index_pointer += _xy_segment2_xy_operators_operator0_result_ncomponents;
    _xy_wavefunction_index_pointer += _xy_wavefunction_ncomponents;
  }
  #undef T
  #undef _T_phi
  #undef phi
  
  _xy_segment2_xy_operators_operator0_result_basis = 0;
  _active_xy_wavefunction = __backup_ptr;
  _xy_wavefunction_basis = __backup_basis;
}


// EX transverse derivative operator for field xy
void _segment2_xy_operators_calculate_operator0_field()
{
  long _xy_segment2_xy_operators_operator0_field_index_pointer = 0;
  #define T _active_xy_segment2_xy_operators_operator0_field[_xy_segment2_xy_operators_operator0_field_index_pointer + 0]
  #define ky _ky[_index_ky + _local_swapped_offset_ky]
  #define dky (_dky * (1.0))
  
  for (long _index_ky = 0; _index_ky < _local_swapped_lattice_ky; _index_ky++) {
    #define kx _kx[_index_kx + 0]
    #define dkx (_dkx * (1.0))
    
    for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
      // ************** Operator code *****************
      #line 119 "./Dynamics.xml"
      
      T = -0.5*(i)*(kx*kx + ky*ky);
      
      #line 2683 "dGPE_Dynamics.cc"
      // **********************************************
      // Increment index pointers for vectors in field xy (or having the same dimensions)
      _xy_segment2_xy_operators_operator0_field_index_pointer += 1 * _xy_segment2_xy_operators_operator0_field_ncomponents;
      
    }
    #undef kx
    #undef dkx
  }
  #undef ky
  #undef dky
  #undef T
}

void _xy_segment2_xy_operators_operator0_result_basis_transform(ptrdiff_t new_basis)
{
  if (_xy_segment2_xy_operators_operator0_result_basis == new_basis)
    return;
  
  if (_xy_segment2_xy_operators_operator0_result_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'xy_segment2_xy_operators_operator0_result' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_xy_segment2_xy_operators_operator0_result_basis_map.count(_basis_pair(_xy_segment2_xy_operators_operator0_result_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'xy_segment2_xy_operators_operator0_result' from basis %s to basis %s.\n",
      _basis_identifiers[_xy_segment2_xy_operators_operator0_result_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _xy_segment2_xy_operators_operator0_result_basis_map[_basis_pair(_xy_segment2_xy_operators_operator0_result_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'xy_segment2_xy_operators_operator0_result' from basis %s to basis %s.\n",
                           _basis_identifiers[_xy_segment2_xy_operators_operator0_result_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_xy_segment2_xy_operators_operator0_result);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _xy_segment2_xy_operators_operator0_result_basis = new_basis;
}

// Delta A propagation operator for field xy
void _segment2_xy_operators_evaluate_operator1(real _step)
{
  // Transforming vectors to basis (distributed x, y)
  _xy_kinetic_basis_transform(1); // (distributed x, y)
  _xy_wavefunction_basis_transform(1); // (distributed x, y)
  _xy_segment2_xy_operators_operator0_result_basis_transform(1); // (distributed x, y)
  
  long _xy_gainloss_index_pointer = 0;
  #define V2 _active_xy_gainloss[_xy_gainloss_index_pointer + 0]
  #define loss _active_xy_gainloss[_xy_gainloss_index_pointer + 1]
  long _xy_potential_index_pointer = 0;
  #define V _active_xy_potential[_xy_potential_index_pointer + 0]
  long _xy_segment2_xy_operators_operator0_result_index_pointer = 0;
  #define _T_phi _active_xy_segment2_xy_operators_operator0_result[_xy_segment2_xy_operators_operator0_result_index_pointer + 0]
  long _xy_kinetic_index_pointer = 0;
  #define KE _active_xy_kinetic[_xy_kinetic_index_pointer + 0]
  long _xy_wavefunction_index_pointer = 0;
  #define phi _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0]
  #define x _x[_index_x + _local_unswapped_offset_x]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _local_unswapped_lattice_x; _index_x++) {
    #define y _y[_index_y + 0]
    #define dy (_dy * (1.0))
    
    for (long _index_y = 0; _index_y < _lattice_y; _index_y++) {
      complex dphi_dt;
      
      #define dt _step
      
      // ************* Propagation code ***************
      #line 125 "./Dynamics.xml"
      
      dphi_dt = _T_phi + i*(mu0-V-mod2(phi))*phi - gamma0*loss*(KE+(mod2(phi)+V-V2)*phi);
      // -loss2*phi;
      
      
      #line 2776 "dGPE_Dynamics.cc"
      // **********************************************
      
      #undef dt
      
      
      _active_xy_wavefunction[_xy_wavefunction_index_pointer + 0] = dphi_dt * _step;
      // Increment index pointers for vectors in field xy (or having the same dimensions)
      _xy_gainloss_index_pointer += 1 * _xy_gainloss_ncomponents;
      _xy_potential_index_pointer += 1 * _xy_potential_ncomponents;
      _xy_segment2_xy_operators_operator0_result_index_pointer += 1 * _xy_segment2_xy_operators_operator0_result_ncomponents;
      _xy_kinetic_index_pointer += 1 * _xy_kinetic_ncomponents;
      _xy_wavefunction_index_pointer += 1 * _xy_wavefunction_ncomponents;
      
    }
    #undef y
    #undef dy
  }
  #undef x
  #undef dx
  #undef V2
  #undef loss
  #undef V
  #undef _T_phi
  #undef KE
  #undef phi
}

// ********************************************************
//   segment 3 (Breakpoint) function implementations
void _segment3()
{
  
  _xy_wavefunction_basis_transform(1); // (distributed x, y)
  
  
  char *_baseFilename = (char*)malloc(255);
  _breakpointAutoNameCounter++;
  snprintf(_baseFilename, 255, "%li%s", _breakpointAutoNameCounter, gsArgsAndValues.c_str());
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", _baseFilename);
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", _baseFilename);
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"breakpoint\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>4</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "x y phiR phiI \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_y);
    fprintf(_outfile, "    <Dim>4</Dim>\n");
  }
  
  // Only write to file if we are rank 0, as we cannot assume
  // that the nodes have equal access to the filesystem
  if (_rank == 0) {
  
    char _h5Filename[200];
    snprintf(_h5Filename, 200, "%s.h5", _baseFilename);
    
    /* Open the file */
    hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
      hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
      if (hdf5_file < 0) {
        _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
      }
    }
    
    /* Create the group for this data */
    hid_t group;
    if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
      group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
    else
      group = H5Gopen(hdf5_file, "/1");
    
    if (_outfile) {
      fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
      fprintf(_outfile, "%s.h5\n", _baseFilename);
      fprintf(_outfile, "    </Stream>\n");
    }
    
    /* Create the coordinate data sets */
    hsize_t coordinate_length;
    hid_t coordinate_dataspace;
    coordinate_length = _lattice_x;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_x;
    if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
      dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_x = H5Dopen(hdf5_file, "/1/x");
    H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_x, "x");
    #endif
    
    H5Sclose(coordinate_dataspace);
    coordinate_length = _lattice_y;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_y;
    if (!H5Lexists(hdf5_file, "/1/y", H5P_DEFAULT))
      dataset_y = H5Dcreate(hdf5_file, "/1/y", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_y = H5Dopen(hdf5_file, "/1/y");
    H5Dwrite(dataset_y, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _y);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_y, "y");
    #endif
    
    H5Sclose(coordinate_dataspace);
    
    hsize_t file_dims[] = {_lattice_x, _lattice_y};
    hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
    
    hid_t dataset_phiR;
    if (!H5Lexists(hdf5_file, "/1/phiR", H5P_DEFAULT))
      dataset_phiR = H5Dcreate(hdf5_file, "/1/phiR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_phiR = H5Dopen(hdf5_file, "/1/phiR");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_phiR, dataset_x, 0);
      H5DSattach_scale(dataset_phiR, dataset_y, 1);
    #endif
    hid_t dataset_phiI;
    if (!H5Lexists(hdf5_file, "/1/phiI", H5P_DEFAULT))
      dataset_phiI = H5Dcreate(hdf5_file, "/1/phiI", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_phiI = H5Dopen(hdf5_file, "/1/phiI");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_phiI, dataset_x, 0);
      H5DSattach_scale(dataset_phiI, dataset_y, 1);
    #endif
    H5Dclose(dataset_x);
    H5Dclose(dataset_y);
    
    ptrdiff_t _my_local_unswapped_lattice_x = _local_unswapped_lattice_x;
    ptrdiff_t _my_local_unswapped_offset_x = _local_unswapped_offset_x;
    ptrdiff_t _my_local_unswapped_lattice_kx = _local_unswapped_lattice_kx;
    ptrdiff_t _my_local_unswapped_offset_kx = _local_unswapped_offset_kx;
    ptrdiff_t _my_local_swapped_lattice_y = _local_swapped_lattice_y;
    ptrdiff_t _my_local_swapped_offset_y = _local_swapped_offset_y;
    ptrdiff_t _my_local_swapped_lattice_ky = _local_swapped_lattice_ky;
    ptrdiff_t _my_local_swapped_offset_ky = _local_swapped_offset_ky;
    
    complex* _local_active_xy_wavefunction;
    complex* _backup_active_xy_wavefunction = _active_xy_wavefunction;
    
    for (long _dataForRank = 0; _dataForRank < _size; _dataForRank++) {
      ptrdiff_t _local_unswapped_lattice_x;
      ptrdiff_t _local_unswapped_offset_x;
      ptrdiff_t _local_unswapped_lattice_kx;
      ptrdiff_t _local_unswapped_offset_kx;
      ptrdiff_t _local_swapped_lattice_y;
      ptrdiff_t _local_swapped_offset_y;
      ptrdiff_t _local_swapped_lattice_ky;
      ptrdiff_t _local_swapped_offset_ky;
      ptrdiff_t _local_vector_size;
      
      if (_dataForRank == 0) {
        _local_unswapped_lattice_x = _my_local_unswapped_lattice_x;
        _local_unswapped_offset_x = _my_local_unswapped_offset_x;
        _local_unswapped_lattice_kx = _my_local_unswapped_lattice_kx;
        _local_unswapped_offset_kx = _my_local_unswapped_offset_kx;
        _local_swapped_lattice_y = _my_local_swapped_lattice_y;
        _local_swapped_offset_y = _my_local_swapped_offset_y;
        _local_swapped_lattice_ky = _my_local_swapped_lattice_ky;
        _local_swapped_offset_ky = _my_local_swapped_offset_ky;
        
      } else {
        MPI_Status status;
        MPI_Recv(&_local_unswapped_lattice_x, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_unswapped_offset_x, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_unswapped_lattice_kx, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_unswapped_offset_kx, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_lattice_y, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_offset_y, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_lattice_ky, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_offset_ky, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        
        // Now allocate the space needed locally, and receive the entire buffer
        MPI_Recv(&_local_vector_size, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        if (_local_vector_size == 0)
          continue;
        
        _local_active_xy_wavefunction = (complex*) xmds_malloc(sizeof(real) * _local_vector_size);
        MPI_Recv(_local_active_xy_wavefunction, _local_vector_size,
                 MPI_REAL, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        _active_xy_wavefunction = _local_active_xy_wavefunction;
        
      }
    
    if ((_local_unswapped_lattice_x * _lattice_y)) {
        /* Create the data space */
        hsize_t file_start[2] = {(unsigned long long int)_local_unswapped_offset_x, (unsigned long long int)0};
        hsize_t mem_dims[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
        hsize_t mem_start[3] = {0, 0, 0};
        hsize_t mem_stride[3] = {1, 1, 1};
        hsize_t mem_count[3] = {(unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
        
        
        hid_t mem_dataspace;
        mem_dims[2] = 2;
        mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
        mem_stride[2] = 2;
        
        // Select hyperslabs of memory and file data spaces for data transfer operation
        mem_start[2] = 0;
        H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
        H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
        
        if (dataset_phiR)
          H5Dwrite(dataset_phiR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_wavefunction);
        mem_start[2] = 1;
        H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
        H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
        
        if (dataset_phiI)
          H5Dwrite(dataset_phiI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_xy_wavefunction);
        
        H5Sclose(mem_dataspace);
    }
    
      
      if (_dataForRank != 0) {
        xmds_free(_local_active_xy_wavefunction);
      }
    } // End looping over ranks
    _active_xy_wavefunction = _backup_active_xy_wavefunction;
    
    
    H5Dclose(dataset_phiR);
    H5Dclose(dataset_phiI);
    
    H5Sclose(file_dataspace);
    H5Gclose(group);
    H5Fclose(hdf5_file);
  
  }
  else {
    // We are some other rank that isn't 0, so we need to send our data to rank 0.
    ptrdiff_t _sending_var;
    
    _sending_var = _local_unswapped_lattice_x;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_unswapped_offset_x;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_unswapped_lattice_kx;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_unswapped_offset_kx;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_lattice_y;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_offset_y;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_lattice_ky;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_offset_ky;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    
    _sending_var = 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    if (_sending_var == 0)
      goto _BINARY_WRITE_OUT_END;
    MPI_Ssend(_active_xy_wavefunction, 2 * (_local_unswapped_lattice_x * _lattice_y) * _xy_wavefunction_ncomponents, MPI_REAL, 0, 0, MPI_COMM_WORLD);
    
  _BINARY_WRITE_OUT_END:;
  }
  
  MPI_Barrier(MPI_COMM_WORLD);
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
  
}


FILE* _open_xsil_file(const char* _filename)
{
  // Only let rank 0 do the writing to disk
  if (_rank != 0)
    return NULL;
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "<name>dGPE_Dynamics</name>\n");
  fprintf(fp, "<author>Matt Reeves</author>\n");
  fprintf(fp, "<description>\n");
  fprintf(fp, "Stir an througuh an ellipse with two stirrers at the edges. The ellipse is rotated 45 degrees. \n");
  fprintf(fp, "</description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<features>\n");
  fprintf(fp, "    <validation kind=\"run-time\"/>\n");
  fprintf(fp, "     <arguments>\n");
  fprintf(fp, "        <argument name=\"xmin\" type=\"real\" default_value=\"-128.0\"/>\n");
  fprintf(fp, "        <argument name=\"xmax\" type=\"real\" default_value=\"128.0\"/>\n");
  fprintf(fp, "        <argument name=\"ymin\" type=\"real\" default_value=\"-128.0\"/>\n");
  fprintf(fp, "        <argument name=\"ymax\" type=\"real\" default_value=\"128.0\"/>\n");
  fprintf(fp, "        <argument name=\"numGridPoints1\" type=\"integer\" default_value=\"256\"/>\n");
  fprintf(fp, "        <argument name=\"numGridPoints2\" type=\"integer\" default_value=\"256\"/>\n");
  fprintf(fp, "        <argument name=\"gamma0\" type=\"real\" default_value=\"0.02\"/>\n");
  fprintf(fp, "    </arguments>\n");
  fprintf(fp, "\n");
  fprintf(fp, "    <auto_vectorise/>\n");
  fprintf(fp, "    <diagnostics/>\n");
  fprintf(fp, "    <benchmark/>\n");
  fprintf(fp, "    <!--     <openmp /> -->\n");
  fprintf(fp, "    <bing/>\n");
  fprintf(fp, "    <fftw plan=\"patient\" threads=\"4\"/>\n");
  fprintf(fp, "    <globals>\n");
  fprintf(fp, "    <![CDATA[\n");
  fprintf(fp, "         const double  Uint = 1;\n");
  fprintf(fp, "         const double mu0 = 1.0;\n");
  fprintf(fp, "         const double R1 = 100;\n");
  fprintf(fp, "         const double R2 = 40;\n");
  fprintf(fp, "         ]]>\n");
  fprintf(fp, "    </globals>\n");
  fprintf(fp, "</features>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<driver name=\"distributed-mpi\"/> \n");
  fprintf(fp, "\n");
  fprintf(fp, "<geometry>\n");
  fprintf(fp, "    <propagation_dimension> t </propagation_dimension>\n");
  fprintf(fp, "    <transverse_dimensions>\n");
  fprintf(fp, "        <dimension name=\"x\" lattice=\"numGridPoints1\" domain=\"(xmin, xmax)\"/>  \n");
  fprintf(fp, "        <dimension name=\"y\" lattice=\"numGridPoints2\" domain=\"(ymin, ymax)\"/>\n");
  fprintf(fp, "        </transverse_dimensions>\n");
  fprintf(fp, "</geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<vector name=\"potential\" dimensions=\"x y\" type=\"real\">\n");
  fprintf(fp, "        <components> V </components>\n");
  fprintf(fp, "    <initialisation kind=\"hdf5\"> \n");
  fprintf(fp, "        <filename> Potential.h5 </filename>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "</vector>\n");
  fprintf(fp, "<vector name=\"init_wavefunction\" dimensions=\"x y\" type=\"real\">\n");
  fprintf(fp, "        <components> phiR phiI </components>\n");
  fprintf(fp, "    <initialisation kind=\"hdf5\"> \n");
  fprintf(fp, "        <filename> Groundstate.h5 </filename>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "</vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "\n");
  fprintf(fp, "<!-- <vector name=\"gainloss\" dimensions=\"x y\" type=\"real\">\n");
  fprintf(fp, "<components> V2 loss loss2</components>\n");
  fprintf(fp, "<initialisation>\n");
  fprintf(fp, "<dependencies> </dependencies>\n");
  fprintf(fp, "<![CDATA[\n");
  fprintf(fp, "if (x*x+y*y>110*110){\n");
  fprintf(fp, "        V2 = 1.7;\n");
  fprintf(fp, "        loss = 1.5;\n");
  fprintf(fp, "    }\n");
  fprintf(fp, "    if (x*x+y*y < 80*80){\n");
  fprintf(fp, "      V2 = 1.0;\n");
  fprintf(fp, "      loss = 0.0005;\n");
  fprintf(fp, "      loss2 = 0.0;\n");
  fprintf(fp, "      }\n");
  fprintf(fp, "    ]]>\n");
  fprintf(fp, "</initialisation>\n");
  fprintf(fp, "</vector> -->\n");
  fprintf(fp, "\n");
  fprintf(fp, "<vector name=\"gainloss\" dimensions=\"x y\" type=\"real\">\n");
  fprintf(fp, "<components> V2 loss </components>\n");
  fprintf(fp, "<initialisation kind=\"hdf5\">\n");
  fprintf(fp, "    <filename> Losses.h5 </filename>\n");
  fprintf(fp, "</initialisation>\n");
  fprintf(fp, "</vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<noise_vector name=\"initial_noise\" dimensions=\"x y\" type=\"real\" kind=\"gauss\">\n");
  fprintf(fp, "    <components> fuzz1 fuzz2 </components>\n");
  fprintf(fp, "</noise_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<vector name=\"wavefunction\" dimensions=\"x y\" type=\"complex\">\n");
  fprintf(fp, "    <components> phi </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "        <dependencies> init_wavefunction initial_noise  </dependencies>\n");
  fprintf(fp, "        <![CDATA[ \n");
  fprintf(fp, "             phi = phiR + i*phiI;\n");
  fprintf(fp, "             phi += 1e-3*(fuzz1 + i*fuzz2);\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "</vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<computed_vector name=\"kinetic\" dimensions=\"x y\" type=\"complex\">\n");
  fprintf(fp, "    <components>  KE  </components>\n");
  fprintf(fp, "    <evaluation>\n");
  fprintf(fp, "    <dependencies basis=\"kx ky\"> wavefunction </dependencies>\n");
  fprintf(fp, "    <![CDATA[\n");
  fprintf(fp, "    KE =  0.5*(kx*kx+ky*ky)*phi;\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "     </evaluation>\n");
  fprintf(fp, "</computed_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<sequence cycles=\"1000\">\n");
  fprintf(fp, "    <filter>\n");
  fprintf(fp, "        <![CDATA[ printf(\"Hello world from a filter segment!\\n\");  ]]>\n");
  fprintf(fp, "    </filter>\n");
  fprintf(fp, "    <integrate algorithm=\"ARK45\" interval=\"10\" steps=\"2000\" tolerance=\"1e-6\">\n");
  fprintf(fp, "        <samples> 1 </samples>\n");
  fprintf(fp, "        <operators>\n");
  fprintf(fp, "            <operator kind=\"ex\" constant=\"yes\" type=\"complex\">\n");
  fprintf(fp, "            <operator_names>T </operator_names>\n");
  fprintf(fp, "            <![CDATA[\n");
  fprintf(fp, "                T = -0.5*(i)*(kx*kx + ky*ky);\n");
  fprintf(fp, "             ]]>\n");
  fprintf(fp, "            </operator>\n");
  fprintf(fp, "            <integration_vectors>wavefunction</integration_vectors>\n");
  fprintf(fp, "            <dependencies basis=\"x y\"> potential gainloss kinetic </dependencies> \n");
  fprintf(fp, "            <![CDATA[\n");
  fprintf(fp, "            dphi_dt = T[phi] + i*(mu0-V-mod2(phi))*phi - gamma0*loss*(KE+(mod2(phi)+V-V2)*phi);\n");
  fprintf(fp, "            // -loss2*phi;\n");
  fprintf(fp, "            \n");
  fprintf(fp, "            ]]>\n");
  fprintf(fp, "        </operators>\n");
  fprintf(fp, "     </integrate>\n");
  fprintf(fp, "     <breakpoint format=\"hdf5\">\n");
  fprintf(fp, "        <dependencies basis=\"x y\">wavefunction </dependencies>\n");
  fprintf(fp, "    </breakpoint>\n");
  fprintf(fp, "</sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "<output format=\"hdf5\" filename=\"JUNK_OUT.xsil\">\n");
  fprintf(fp, "<sampling_group basis=\"x y\" initial_sample=\"no\">\n");
  fprintf(fp, "<moments> JUNK1 JUNK2 </moments>\n");
  fprintf(fp, "<dependencies> gainloss  </dependencies>\n");
  fprintf(fp, "<![CDATA[\n");
  fprintf(fp, "JUNK1 = loss;\n");
  fprintf(fp, "JUNK2 = V2;\n");
  fprintf(fp, "         ]]> \n");
  fprintf(fp, "</sampling_group>\n");
  fprintf(fp, "</output> \n");
  fprintf(fp, "\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 3.0.0 \"Release the Kraken\" (r3072)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "\nVariables that can be specified on the command line:\n");
  
  fprintf(fp, "  Command line argument xmin = %e\n", xmin);
  
  fprintf(fp, "  Command line argument xmax = %e\n", xmax);
  
  fprintf(fp, "  Command line argument ymin = %e\n", ymin);
  
  fprintf(fp, "  Command line argument ymax = %e\n", ymax);
  
  fprintf(fp, "  Command line argument numGridPoints1 = %li\n", numGridPoints1);
  
  fprintf(fp, "  Command line argument numGridPoints2 = %li\n", numGridPoints2);
  
  fprintf(fp, "  Command line argument gamma0 = %e\n", gamma0);
  fprintf(fp, "\nNo seeds were provided for noise vector 'initial_noise'. The seeds generated were:\n");
  fprintf(fp, "    %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", _gen_initial_noise_seeds[0], _gen_initial_noise_seeds[1], _gen_initial_noise_seeds[2], _gen_initial_noise_seeds[3], _gen_initial_noise_seeds[4], _gen_initial_noise_seeds[5], _gen_initial_noise_seeds[6], _gen_initial_noise_seeds[7], _gen_initial_noise_seeds[8], _gen_initial_noise_seeds[9]);
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for dGPE_Dynamics\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("JUNK_OUT" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("JUNK_OUT" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  long _mg0_output_raw_index_pointer = 0;
  #define JUNK1 _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define JUNK2 _active_mg0_output_raw[_mg0_output_raw_index_pointer + 1]
  long _xy_gainloss_index_pointer = 0;
  #define V2 _active_xy_gainloss[_xy_gainloss_index_pointer + 0]
  #define loss _active_xy_gainloss[_xy_gainloss_index_pointer + 1]
  #define x _x[_index_x + _local_unswapped_offset_x]
  #define dx (_dx * (1.0))
  
  for (long _index_x = 0; _index_x < _local_unswapped_lattice_x; _index_x++) {
    #define y _y[_index_y + 0]
    #define dy (_dy * (1.0))
    
    for (long _index_y = 0; _index_y < _lattice_y; _index_y++) {
      // Set index pointers explicitly for (some) vectors
      _mg0_output_raw_index_pointer = ( 0
         + _mg0_output_index_t  * _local_unswapped_lattice_x * _lattice_y
         + ( _index_x + _local_unswapped_offset_x - _local_unswapped_offset_x ) * _lattice_y
         + _index_y * 1 ) * _mg0_output_raw_ncomponents;
      #define _SAMPLE_COMPLEX(variable) \
                variable ## R = variable.Re(); variable ## I = variable.Im();
      
      // *************** Sampling code ****************
      #line 141 "./Dynamics.xml"
      
      JUNK1 = loss;
      JUNK2 = V2;
      
      #line 3350 "dGPE_Dynamics.cc"
      // **********************************************
      
      #undef _SAMPLE_COMPLEX
      // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
      _xy_gainloss_index_pointer += 1 * _xy_gainloss_ncomponents;
      
    }
    #undef y
    #undef dy
  }
  #undef x
  #undef dx
  #undef JUNK1
  #undef JUNK2
  #undef V2
  #undef loss
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  // No post processing needs to be done
}


void _mg0_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">3</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>5</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t x y JUNK1 JUNK2 \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_y);
    fprintf(_outfile, "    <Dim>5</Dim>\n");
  }
  
  // Only write to file if we are rank 0, as we cannot assume
  // that the nodes have equal access to the filesystem
  if (_rank == 0) {
  
    char _h5Filename[200];
    snprintf(_h5Filename, 200, "%s.h5", ("JUNK_OUT" + gsArgsAndValues).c_str());
    
    /* Open the file */
    hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
      hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
      if (hdf5_file < 0) {
        _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
      }
    }
    
    /* Create the group for this data */
    hid_t group;
    if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
      group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
    else
      group = H5Gopen(hdf5_file, "/1");
    
    if (_outfile) {
      fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
      fprintf(_outfile, "%s.h5\n", ("JUNK_OUT" + gsArgsAndValues).c_str());
      fprintf(_outfile, "    </Stream>\n");
    }
    
    /* Create the coordinate data sets */
    hsize_t coordinate_length;
    hid_t coordinate_dataspace;
    coordinate_length = _mg0_output_lattice_t;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_t;
    if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
      dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_t = H5Dopen(hdf5_file, "/1/t");
    H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_t, "t");
    #endif
    
    H5Sclose(coordinate_dataspace);
    coordinate_length = _lattice_x;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_x;
    if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
      dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_x = H5Dopen(hdf5_file, "/1/x");
    H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_x, "x");
    #endif
    
    H5Sclose(coordinate_dataspace);
    coordinate_length = _lattice_y;
    coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    hid_t dataset_y;
    if (!H5Lexists(hdf5_file, "/1/y", H5P_DEFAULT))
      dataset_y = H5Dcreate(hdf5_file, "/1/y", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
    else
      dataset_y = H5Dopen(hdf5_file, "/1/y");
    H5Dwrite(dataset_y, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _y);
    #if defined(HAVE_HDF5_HL)
      H5DSset_scale(dataset_y, "y");
    #endif
    
    H5Sclose(coordinate_dataspace);
    
    hsize_t file_dims[] = {_mg0_output_lattice_t, _lattice_x, _lattice_y};
    hid_t file_dataspace = H5Screate_simple(3, file_dims, NULL);
    
    hid_t dataset_JUNK1;
    if (!H5Lexists(hdf5_file, "/1/JUNK1", H5P_DEFAULT))
      dataset_JUNK1 = H5Dcreate(hdf5_file, "/1/JUNK1", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_JUNK1 = H5Dopen(hdf5_file, "/1/JUNK1");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_JUNK1, dataset_t, 0);
      H5DSattach_scale(dataset_JUNK1, dataset_x, 1);
      H5DSattach_scale(dataset_JUNK1, dataset_y, 2);
    #endif
    hid_t dataset_JUNK2;
    if (!H5Lexists(hdf5_file, "/1/JUNK2", H5P_DEFAULT))
      dataset_JUNK2 = H5Dcreate(hdf5_file, "/1/JUNK2", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
    else
      dataset_JUNK2 = H5Dopen(hdf5_file, "/1/JUNK2");
    #if defined(HAVE_HDF5_HL)
      H5DSattach_scale(dataset_JUNK2, dataset_t, 0);
      H5DSattach_scale(dataset_JUNK2, dataset_x, 1);
      H5DSattach_scale(dataset_JUNK2, dataset_y, 2);
    #endif
    H5Dclose(dataset_t);
    H5Dclose(dataset_x);
    H5Dclose(dataset_y);
    
    ptrdiff_t _my_local_unswapped_lattice_x = _local_unswapped_lattice_x;
    ptrdiff_t _my_local_unswapped_offset_x = _local_unswapped_offset_x;
    ptrdiff_t _my_local_unswapped_lattice_kx = _local_unswapped_lattice_kx;
    ptrdiff_t _my_local_unswapped_offset_kx = _local_unswapped_offset_kx;
    ptrdiff_t _my_local_swapped_lattice_y = _local_swapped_lattice_y;
    ptrdiff_t _my_local_swapped_offset_y = _local_swapped_offset_y;
    ptrdiff_t _my_local_swapped_lattice_ky = _local_swapped_lattice_ky;
    ptrdiff_t _my_local_swapped_offset_ky = _local_swapped_offset_ky;
    
    real* _local_active_mg0_output_raw;
    real* _backup_active_mg0_output_raw = _active_mg0_output_raw;
    
    for (long _dataForRank = 0; _dataForRank < _size; _dataForRank++) {
      ptrdiff_t _local_unswapped_lattice_x;
      ptrdiff_t _local_unswapped_offset_x;
      ptrdiff_t _local_unswapped_lattice_kx;
      ptrdiff_t _local_unswapped_offset_kx;
      ptrdiff_t _local_swapped_lattice_y;
      ptrdiff_t _local_swapped_offset_y;
      ptrdiff_t _local_swapped_lattice_ky;
      ptrdiff_t _local_swapped_offset_ky;
      ptrdiff_t _local_vector_size;
      
      if (_dataForRank == 0) {
        _local_unswapped_lattice_x = _my_local_unswapped_lattice_x;
        _local_unswapped_offset_x = _my_local_unswapped_offset_x;
        _local_unswapped_lattice_kx = _my_local_unswapped_lattice_kx;
        _local_unswapped_offset_kx = _my_local_unswapped_offset_kx;
        _local_swapped_lattice_y = _my_local_swapped_lattice_y;
        _local_swapped_offset_y = _my_local_swapped_offset_y;
        _local_swapped_lattice_ky = _my_local_swapped_lattice_ky;
        _local_swapped_offset_ky = _my_local_swapped_offset_ky;
        
      } else {
        MPI_Status status;
        MPI_Recv(&_local_unswapped_lattice_x, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_unswapped_offset_x, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_unswapped_lattice_kx, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_unswapped_offset_kx, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_lattice_y, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_offset_y, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_lattice_ky, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        MPI_Recv(&_local_swapped_offset_ky, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        
        // Now allocate the space needed locally, and receive the entire buffer
        MPI_Recv(&_local_vector_size, sizeof(ptrdiff_t), MPI_BYTE, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        if (_local_vector_size == 0)
          continue;
        
        _local_active_mg0_output_raw = (real*) xmds_malloc(sizeof(real) * _local_vector_size);
        MPI_Recv(_local_active_mg0_output_raw, _local_vector_size,
                 MPI_REAL, _dataForRank, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
        _active_mg0_output_raw = _local_active_mg0_output_raw;
        
      }
    
    if ((_mg0_output_lattice_t * _local_unswapped_lattice_x * _lattice_y)) {
        /* Create the data space */
        hsize_t file_start[3] = {(unsigned long long int)0, (unsigned long long int)_local_unswapped_offset_x, (unsigned long long int)0};
        hsize_t mem_dims[4] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
        hsize_t mem_start[4] = {0, 0, 0, 0};
        hsize_t mem_stride[4] = {1, 1, 1, 1};
        hsize_t mem_count[4] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_local_unswapped_lattice_x, (unsigned long long int)_lattice_y, (unsigned long long int)1};
        
        
        hid_t mem_dataspace;
        mem_dims[3] = 2;
        mem_dataspace = H5Screate_simple(4, mem_dims, NULL);
        mem_stride[3] = 2;
        
        // Select hyperslabs of memory and file data spaces for data transfer operation
        mem_start[3] = 0;
        H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
        H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
        
        if (dataset_JUNK1)
          H5Dwrite(dataset_JUNK1, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
        mem_start[3] = 1;
        H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
        H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
        
        if (dataset_JUNK2)
          H5Dwrite(dataset_JUNK2, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
        
        H5Sclose(mem_dataspace);
    }
    
      
      if (_dataForRank != 0) {
        xmds_free(_local_active_mg0_output_raw);
      }
    } // End looping over ranks
    _active_mg0_output_raw = _backup_active_mg0_output_raw;
    
    
    H5Dclose(dataset_JUNK1);
    H5Dclose(dataset_JUNK2);
    
    H5Sclose(file_dataspace);
    H5Gclose(group);
    H5Fclose(hdf5_file);
  
  }
  else {
    // We are some other rank that isn't 0, so we need to send our data to rank 0.
    ptrdiff_t _sending_var;
    
    _sending_var = _local_unswapped_lattice_x;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_unswapped_offset_x;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_unswapped_lattice_kx;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_unswapped_offset_kx;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_lattice_y;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_offset_y;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_lattice_ky;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    _sending_var = _local_swapped_offset_ky;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    
    _sending_var = (_mg0_output_lattice_t * _local_unswapped_lattice_x * _lattice_y) * _mg0_output_raw_ncomponents;
    MPI_Ssend(&_sending_var, sizeof(ptrdiff_t), MPI_BYTE, 0, 0, MPI_COMM_WORLD);
    if (_sending_var == 0)
      goto _BINARY_WRITE_OUT_END;
    MPI_Ssend(_active_mg0_output_raw, (_mg0_output_lattice_t * _local_unswapped_lattice_x * _lattice_y) * _mg0_output_raw_ncomponents, MPI_REAL, 0, 0, MPI_COMM_WORLD);
    
  _BINARY_WRITE_OUT_END:;
  }
  
  MPI_Barrier(MPI_COMM_WORLD);
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

